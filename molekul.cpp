#include "molekul.h"
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <QtCore> 
#include <QtOpenGL>
#include <QtGui>
#define Ato4d(arr)       arr[0], arr[1], arr[2], arr[3]
void molekul::sphere(int adp){
  
  if (adp) glEnable(GL_BLEND);
  
  GLUquadricObj *q = gluNewQuadric();
  gluQuadricNormals(q, GL_SMOOTH);
  if (dratom){
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    if (dratom==3)glColor3d(0.4,0.8,1.0);
    if (dratom<3) glColor3d(1.0,1.0,0.0);
    gluQuadricDrawStyle(q,GLU_LINE);
    if (dratom==3)gluSphere(q,0.33,7,7);
    else if (dratom==5)gluSphere(q,1.00,7,7);
    else gluSphere(q,0.3,5,5);
    glEnable(GL_DEPTH_TEST);
  }
  else{
    gluQuadricDrawStyle(q,GLU_FILL);
    if (LOD!=3) gluSphere(q,0.96,4*LOD,9*LOD);  
    else sp(0.96);
    glDisable(GL_BLEND);
  }
  gluDeleteQuadric(q);
  
}

void molekul::sp(GLfloat r){
  static const GLfloat mCubeVerticesData[1122] = { 
    -0.577350f, 0.577350f, 0.577350f,// 0
    0.577350f, 0.577350f, 0.577350f,// 1
    -0.577350f, -0.577350f, 0.577350f,// 2
    0.577350f, -0.577350f, 0.577350f,// 3
    -0.577350f, 0.577350f, -0.577350f,// 4
    0.577350f, 0.577350f, -0.577350f,// 5
    -0.577350f, -0.577350f, -0.577350f,// 6
    0.577350f, -0.577350f, -0.577350f,// 7
    0.000000f, 1.000000f, 0.000000f,// 8
    1.000000f, 0.000000f, 0.000000f,// 9
    0.000000f, -1.000000f, 0.000000f,// 10
    0.000000f, 0.000000f, 1.000000f,// 11
    -1.000000f, 0.000000f, 0.000000f,// 12
    0.000000f, 0.000000f, -1.000000f,// 13
    0.707107f, 0.707107f, 0.000000f,// 14
    0.000000f, 0.707107f, -0.707107f,// 15
    -0.707107f, 0.707107f, 0.000000f,// 16
    0.000000f, 0.707107f, 0.707107f,// 17
    0.707107f, 0.000000f, -0.707107f,// 18
    0.707107f, 0.707107f, 0.000000f,// 19
    0.707107f, 0.000000f, 0.707107f,// 20
    0.707107f, -0.707107f, 0.000000f,// 21
    0.000000f, -0.707107f, -0.707107f,// 22
    0.707107f, -0.707107f, 0.000000f,// 23
    0.000000f, -0.707107f, 0.707107f,// 24
    -0.707107f, -0.707107f, 0.000000f,// 25
    0.000000f, -0.707107f, 0.707107f,// 26
    0.707107f, 0.000000f, 0.707107f,// 27
    0.000000f, 0.707107f, 0.707107f,// 28
    -0.707107f, 0.000000f, 0.707107f,// 29
    -0.707107f, 0.707107f, 0.000000f,// 30
    -0.707107f, 0.000000f, -0.707107f,// 31
    -0.707107f, -0.707107f, 0.000000f,// 32
    -0.707107f, 0.000000f, 0.707107f,// 33
    0.707107f, 0.000000f, -0.707107f,// 34
    0.000000f, -0.707107f, -0.707107f,// 35
    -0.707107f, 0.000000f, -0.707107f,// 36
    0.000000f, 0.707107f, -0.707107f,// 37
    0.325058f, 0.888074f, -0.325058f,// 38
    0.325058f, 0.888074f, 0.325058f,// 39
    -0.325058f, 0.888074f, -0.325058f,// 40
    0.325058f, 0.888074f, -0.325058f,// 41
    -0.325058f, 0.888074f, 0.325058f,// 42
    -0.325058f, 0.888074f, -0.325058f,// 43
    0.325058f, 0.888074f, 0.325058f,// 44
    -0.325058f, 0.888074f, 0.325058f,// 45
    0.888074f, 0.325058f, -0.325058f,// 46
    0.888074f, -0.325058f, -0.325058f,// 47
    0.888074f, 0.325058f, 0.325058f,// 48
    0.888074f, 0.325058f, -0.325058f,// 49
    0.888074f, -0.325058f, 0.325058f,// 50
    0.888074f, 0.325058f, 0.325058f,// 51
    0.888074f, -0.325058f, -0.325058f,// 52
    0.888074f, -0.325058f, 0.325058f,// 53
    0.325058f, -0.888074f, -0.325058f,// 54
    -0.325058f, -0.888074f, -0.325058f,// 55
    0.325058f, -0.888074f, 0.325058f,// 56
    0.325058f, -0.888074f, -0.325058f,// 57
    -0.325058f, -0.888074f, 0.325058f,// 58
    0.325058f, -0.888074f, 0.325058f,// 59
    -0.325058f, -0.888074f, -0.325058f,// 60
    -0.325058f, -0.888074f, 0.325058f,// 61
    0.325058f, -0.325058f, 0.888074f,// 62
    -0.325058f, -0.325058f, 0.888074f,// 63
    0.325058f, 0.325058f, 0.888074f,// 64
    0.325058f, -0.325058f, 0.888074f,// 65
    -0.325058f, 0.325058f, 0.888074f,// 66
    0.325058f, 0.325058f, 0.888074f,// 67
    -0.325058f, -0.325058f, 0.888074f,// 68
    -0.325058f, 0.325058f, 0.888074f,// 69
    -0.888074f, 0.325058f, -0.325058f,// 70
    -0.888074f, 0.325058f, 0.325058f,// 71
    -0.888074f, -0.325058f, -0.325058f,// 72
    -0.888074f, 0.325058f, -0.325058f,// 73
    -0.888074f, -0.325058f, 0.325058f,// 74
    -0.888074f, -0.325058f, -0.325058f,// 75
    -0.888074f, 0.325058f, 0.325058f,// 76
    -0.888074f, -0.325058f, 0.325058f,// 77
    0.325058f, -0.325058f, -0.888074f,// 78
    0.325058f, 0.325058f, -0.888074f,// 79
    -0.325058f, -0.325058f, -0.888074f,// 80
    0.325058f, -0.325058f, -0.888074f,// 81
    -0.325058f, 0.325058f, -0.888074f,// 82
    -0.325058f, -0.325058f, -0.888074f,// 83
    0.325058f, 0.325058f, -0.888074f,// 84
    -0.325058f, 0.325058f, -0.888074f,// 85
    0.382683f, 0.923880f, 0.000000f,// 86
    0.673887f, 0.673887f, -0.302905f,// 87
    0.673887f, 0.673887f, 0.302905f,// 88
    0.382683f, 0.923880f, 0.000000f,// 89
    0.000000f, 0.923880f, -0.382683f,// 90
    -0.302905f, 0.673887f, -0.673887f,// 91
    0.302905f, 0.673887f, -0.673887f,// 92
    0.000000f, 0.923880f, -0.382683f,// 93
    -0.382683f, 0.923880f, 0.000000f,// 94
    -0.673887f, 0.673887f, 0.302905f,// 95
    -0.673887f, 0.673887f, -0.302905f,// 96
    -0.382683f, 0.923880f, 0.000000f,// 97
    0.000000f, 0.923880f, 0.382683f,// 98
    0.302905f, 0.673887f, 0.673887f,// 99
    -0.302905f, 0.673887f, 0.673887f,// 100
    0.000000f, 0.923880f, 0.382683f,// 101
    0.923880f, 0.000000f, -0.382683f,// 102
    0.673887f, 0.302905f, -0.673887f,// 103
    0.673887f, -0.302905f, -0.673887f,// 104
    0.923880f, 0.000000f, -0.382683f,// 105
    0.923880f, 0.382683f, 0.000000f,// 106
    0.673887f, 0.673887f, 0.302905f,// 107
    0.673887f, 0.673887f, -0.302905f,// 108
    0.923880f, 0.382683f, 0.000000f,// 109
    0.923880f, 0.000000f, 0.382683f,// 110
    0.673887f, -0.302905f, 0.673887f,// 111
    0.673887f, 0.302905f, 0.673887f,// 112
    0.923880f, 0.000000f, 0.382683f,// 113
    0.923880f, -0.382683f, 0.000000f,// 114
    0.673887f, -0.673887f, -0.302905f,// 115
    0.673887f, -0.673887f, 0.302905f,// 116
    0.923880f, -0.382683f, 0.000000f,// 117
    0.000000f, -0.923880f, -0.382683f,// 118
    0.302905f, -0.673887f, -0.673887f,// 119
    -0.302905f, -0.673887f, -0.673887f,// 120
    0.000000f, -0.923880f, -0.382683f,// 121
    0.382683f, -0.923880f, 0.000000f,// 122
    0.673887f, -0.673887f, 0.302905f,// 123
    0.673887f, -0.673887f, -0.302905f,// 124
    0.382683f, -0.923880f, 0.000000f,// 125
    0.000000f, -0.923880f, 0.382683f,// 126
    -0.302905f, -0.673887f, 0.673887f,// 127
    0.302905f, -0.673887f, 0.673887f,// 128
    0.000000f, -0.923880f, 0.382683f,// 129
    -0.382683f, -0.923880f, 0.000000f,// 130
    -0.673887f, -0.673887f, -0.302905f,// 131
    -0.673887f, -0.673887f, 0.302905f,// 132
    -0.382683f, -0.923880f, 0.000000f,// 133
    0.000000f, -0.382683f, 0.923880f,// 134
    0.302905f, -0.673887f, 0.673887f,// 135
    -0.302905f, -0.673887f, 0.673887f,// 136
    0.000000f, -0.382683f, 0.923880f,// 137
    0.382683f, 0.000000f, 0.923880f,// 138
    0.673887f, 0.302905f, 0.673887f,// 139
    0.673887f, -0.302905f, 0.673887f,// 140
    0.382683f, 0.000000f, 0.923880f,// 141
    0.000000f, 0.382683f, 0.923880f,// 142
    -0.302905f, 0.673887f, 0.673887f,// 143
    0.302905f, 0.673887f, 0.673887f,// 144
    0.000000f, 0.382683f, 0.923880f,// 145
    -0.382683f, 0.000000f, 0.923880f,// 146
    -0.673887f, -0.302905f, 0.673887f,// 147
    -0.673887f, 0.302905f, 0.673887f,// 148
    -0.382683f, 0.000000f, 0.923880f,// 149
    -0.923880f, 0.382683f, 0.000000f,// 150
    -0.673887f, 0.673887f, -0.302905f,// 151
    -0.673887f, 0.673887f, 0.302905f,// 152
    -0.923880f, 0.382683f, 0.000000f,// 153
    -0.923880f, 0.000000f, -0.382683f,// 154
    -0.673887f, -0.302905f, -0.673887f,// 155
    -0.673887f, 0.302905f, -0.673887f,// 156
    -0.923880f, 0.000000f, -0.382683f,// 157
    -0.923880f, -0.382683f, 0.000000f,// 158
    -0.673887f, -0.673887f, 0.302905f,// 159
    -0.673887f, -0.673887f, -0.302905f,// 160
    -0.923880f, -0.382683f, 0.000000f,// 161
    -0.923880f, 0.000000f, 0.382683f,// 162
    -0.673887f, 0.302905f, 0.673887f,// 163
    -0.673887f, -0.302905f, 0.673887f,// 164
    -0.923880f, 0.000000f, 0.382683f,// 165
    0.382683f, 0.000000f, -0.923880f,// 166
    0.673887f, -0.302905f, -0.673887f,// 167
    0.673887f, 0.302905f, -0.673887f,// 168
    0.382683f, 0.000000f, -0.923880f,// 169
    0.000000f, -0.382683f, -0.923880f,// 170
    -0.302905f, -0.673887f, -0.673887f,// 171
    0.302905f, -0.673887f, -0.673887f,// 172
    0.000000f, -0.382683f, -0.923880f,// 173
    -0.382683f, 0.000000f, -0.923880f,// 174
    -0.673887f, 0.302905f, -0.673887f,// 175
    -0.673887f, -0.302905f, -0.673887f,// 176
    -0.382683f, 0.000000f, -0.923880f,// 177
    0.000000f, 0.382683f, -0.923880f,// 178
    0.302905f, 0.673887f, -0.673887f,// 179
    -0.302905f, 0.673887f, -0.673887f,// 180
    0.000000f, 0.382683f, -0.923880f,// 181
    0.535467f, 0.827549f, -0.168634f,// 182
    0.167277f, 0.971616f, -0.167277f,// 183
    0.464385f, 0.754117f, -0.464385f,// 184
    0.535467f, 0.827549f, -0.168634f,// 185
    0.535467f, 0.827549f, 0.168634f,// 186
    0.464385f, 0.754117f, 0.464385f,// 187
    0.167277f, 0.971616f, 0.167277f,// 188
    0.535467f, 0.827549f, 0.168634f,// 189
    -0.168634f, 0.827549f, -0.535467f,// 190
    -0.167277f, 0.971616f, -0.167277f,// 191
    -0.464385f, 0.754117f, -0.464385f,// 192
    -0.168634f, 0.827549f, -0.535467f,// 193
    0.168634f, 0.827549f, -0.535467f,// 194
    0.464385f, 0.754117f, -0.464385f,// 195
    0.167277f, 0.971616f, -0.167277f,// 196
    0.168634f, 0.827549f, -0.535467f,// 197
    -0.535467f, 0.827549f, 0.168634f,// 198
    -0.167277f, 0.971616f, 0.167277f,// 199
    -0.464385f, 0.754117f, 0.464385f,// 200
    -0.535467f, 0.827549f, 0.168634f,// 201
    -0.535467f, 0.827549f, -0.168634f,// 202
    -0.464385f, 0.754117f, -0.464385f,// 203
    -0.167277f, 0.971616f, -0.167277f,// 204
    -0.535467f, 0.827549f, -0.168634f,// 205
    0.168634f, 0.827549f, 0.535467f,// 206
    0.167277f, 0.971616f, 0.167277f,// 207
    0.464385f, 0.754117f, 0.464385f,// 208
    0.168634f, 0.827549f, 0.535467f,// 209
    -0.168634f, 0.827549f, 0.535467f,// 210
    -0.464385f, 0.754117f, 0.464385f,// 211
    -0.167277f, 0.971616f, 0.167277f,// 212
    -0.168634f, 0.827549f, 0.535467f,// 213
    0.827549f, 0.168634f, -0.535467f,// 214
    0.971616f, 0.167277f, -0.167277f,// 215
    0.754117f, 0.464385f, -0.464385f,// 216
    0.827549f, 0.168634f, -0.535467f,// 217
    0.827549f, -0.168634f, -0.535467f,// 218
    0.754117f, -0.464385f, -0.464385f,// 219
    0.971616f, -0.167277f, -0.167277f,// 220
    0.827549f, -0.168634f, -0.535467f,// 221
    0.827549f, 0.535467f, 0.168634f,// 222
    0.971616f, 0.167277f, 0.167277f,// 223
    0.754117f, 0.464385f, 0.464385f,// 224
    0.827549f, 0.535467f, 0.168634f,// 225
    0.827549f, 0.535467f, -0.168634f,// 226
    0.754117f, 0.464385f, -0.464385f,// 227
    0.971616f, 0.167277f, -0.167277f,// 228
    0.827549f, 0.535467f, -0.168634f,// 229
    0.827549f, -0.168634f, 0.535467f,// 230
    0.971616f, -0.167277f, 0.167277f,// 231
    0.754117f, -0.464385f, 0.464385f,// 232
    0.827549f, -0.168634f, 0.535467f,// 233
    0.827549f, 0.168634f, 0.535467f,// 234
    0.754117f, 0.464385f, 0.464385f,// 235
    0.971616f, 0.167277f, 0.167277f,// 236
    0.827549f, 0.168634f, 0.535467f,// 237
    0.827549f, -0.535467f, -0.168634f,// 238
    0.971616f, -0.167277f, -0.167277f,// 239
    0.754117f, -0.464385f, -0.464385f,// 240
    0.827549f, -0.535467f, -0.168634f,// 241
    0.827549f, -0.535467f, 0.168634f,// 242
    0.754117f, -0.464385f, 0.464385f,// 243
    0.971616f, -0.167277f, 0.167277f,// 244
    0.827549f, -0.535467f, 0.168634f,// 245
    0.168634f, -0.827549f, -0.535467f,// 246
    0.167277f, -0.971616f, -0.167277f,// 247
    0.464385f, -0.754117f, -0.464385f,// 248
    0.168634f, -0.827549f, -0.535467f,// 249
    -0.168634f, -0.827549f, -0.535467f,// 250
    -0.464385f, -0.754117f, -0.464385f,// 251
    -0.167277f, -0.971616f, -0.167277f,// 252
    -0.168634f, -0.827549f, -0.535467f,// 253
    0.535467f, -0.827549f, 0.168634f,// 254
    0.167277f, -0.971616f, 0.167277f,// 255
    0.464385f, -0.754117f, 0.464385f,// 256
    0.535467f, -0.827549f, 0.168634f,// 257
    0.535467f, -0.827549f, -0.168634f,// 258
    0.464385f, -0.754117f, -0.464385f,// 259
    0.167277f, -0.971616f, -0.167277f,// 260
    0.535467f, -0.827549f, -0.168634f,// 261
    -0.168634f, -0.827549f, 0.535467f,// 262
    -0.167277f, -0.971616f, 0.167277f,// 263
    -0.464385f, -0.754117f, 0.464385f,// 264
    -0.168634f, -0.827549f, 0.535467f,// 265
    0.168634f, -0.827549f, 0.535467f,// 266
    0.464385f, -0.754117f, 0.464385f,// 267
    0.167277f, -0.971616f, 0.167277f,// 268
    0.168634f, -0.827549f, 0.535467f,// 269
    -0.535467f, -0.827549f, -0.168634f,// 270
    -0.167277f, -0.971616f, -0.167277f,// 271
    -0.464385f, -0.754117f, -0.464385f,// 272
    -0.535467f, -0.827549f, -0.168634f,// 273
    -0.535467f, -0.827549f, 0.168634f,// 274
    -0.464385f, -0.754117f, 0.464385f,// 275
    -0.167277f, -0.971616f, 0.167277f,// 276
    -0.535467f, -0.827549f, 0.168634f,// 277
    0.168634f, -0.535467f, 0.827549f,// 278
    0.167277f, -0.167277f, 0.971616f,// 279
    0.464385f, -0.464385f, 0.754117f,// 280
    0.168634f, -0.535467f, 0.827549f,// 281
    -0.168634f, -0.535467f, 0.827549f,// 282
    -0.464385f, -0.464385f, 0.754117f,// 283
    -0.167277f, -0.167277f, 0.971616f,// 284
    -0.168634f, -0.535467f, 0.827549f,// 285
    0.535467f, 0.168634f, 0.827549f,// 286
    0.167277f, 0.167277f, 0.971616f,// 287
    0.464385f, 0.464385f, 0.754117f,// 288
    0.535467f, 0.168634f, 0.827549f,// 289
    0.535467f, -0.168634f, 0.827549f,// 290
    0.464385f, -0.464385f, 0.754117f,// 291
    0.167277f, -0.167277f, 0.971616f,// 292
    0.535467f, -0.168634f, 0.827549f,// 293
    -0.168634f, 0.535467f, 0.827549f,// 294
    -0.167277f, 0.167277f, 0.971616f,// 295
    -0.464385f, 0.464385f, 0.754117f,// 296
    -0.168634f, 0.535467f, 0.827549f,// 297
    0.168634f, 0.535467f, 0.827549f,// 298
    0.464385f, 0.464385f, 0.754117f,// 299
    0.167277f, 0.167277f, 0.971616f,// 300
    0.168634f, 0.535467f, 0.827549f,// 301
    -0.535467f, -0.168634f, 0.827549f,// 302
    -0.167277f, -0.167277f, 0.971616f,// 303
    -0.464385f, -0.464385f, 0.754117f,// 304
    -0.535467f, -0.168634f, 0.827549f,// 305
    -0.535467f, 0.168634f, 0.827549f,// 306
    -0.464385f, 0.464385f, 0.754117f,// 307
    -0.167277f, 0.167277f, 0.971616f,// 308
    -0.535467f, 0.168634f, 0.827549f,// 309
    -0.827549f, 0.535467f, -0.168634f,// 310
    -0.971616f, 0.167277f, -0.167277f,// 311
    -0.754117f, 0.464385f, -0.464385f,// 312
    -0.827549f, 0.535467f, -0.168634f,// 313
    -0.827549f, 0.535467f, 0.168634f,// 314
    -0.754117f, 0.464385f, 0.464385f,// 315
    -0.971616f, 0.167277f, 0.167277f,// 316
    -0.827549f, 0.535467f, 0.168634f,// 317
    -0.827549f, -0.168634f, -0.535467f,// 318
    -0.971616f, -0.167277f, -0.167277f,// 319
    -0.754117f, -0.464385f, -0.464385f,// 320
    -0.827549f, -0.168634f, -0.535467f,// 321
    -0.827549f, 0.168634f, -0.535467f,// 322
    -0.754117f, 0.464385f, -0.464385f,// 323
    -0.971616f, 0.167277f, -0.167277f,// 324
    -0.827549f, 0.168634f, -0.535467f,// 325
    -0.827549f, -0.535467f, 0.168634f,// 326
    -0.971616f, -0.167277f, 0.167277f,// 327
    -0.754117f, -0.464385f, 0.464385f,// 328
    -0.827549f, -0.535467f, 0.168634f,// 329
    -0.827549f, -0.535467f, -0.168634f,// 330
    -0.754117f, -0.464385f, -0.464385f,// 331
    -0.971616f, -0.167277f, -0.167277f,// 332
    -0.827549f, -0.535467f, -0.168634f,// 333
    -0.827549f, 0.168634f, 0.535467f,// 334
    -0.971616f, 0.167277f, 0.167277f,// 335
    -0.754117f, 0.464385f, 0.464385f,// 336
    -0.827549f, 0.168634f, 0.535467f,// 337
    -0.827549f, -0.168634f, 0.535467f,// 338
    -0.754117f, -0.464385f, 0.464385f,// 339
    -0.971616f, -0.167277f, 0.167277f,// 340
    -0.827549f, -0.168634f, 0.535467f,// 341
    0.535467f, -0.168634f, -0.827549f,// 342
    0.167277f, -0.167277f, -0.971616f,// 343
    0.464385f, -0.464385f, -0.754117f,// 344
    0.535467f, -0.168634f, -0.827549f,// 345
    0.535467f, 0.168634f, -0.827549f,// 346
    0.464385f, 0.464385f, -0.754117f,// 347
    0.167277f, 0.167277f, -0.971616f,// 348
    0.535467f, 0.168634f, -0.827549f,// 349
    -0.168634f, -0.535467f, -0.827549f,// 350
    -0.167277f, -0.167277f, -0.971616f,// 351
    -0.464385f, -0.464385f, -0.754117f,// 352
    -0.168634f, -0.535467f, -0.827549f,// 353
    0.168634f, -0.535467f, -0.827549f,// 354
    0.464385f, -0.464385f, -0.754117f,// 355
    0.167277f, -0.167277f, -0.971616f,// 356
    0.168634f, -0.535467f, -0.827549f,// 357
    -0.535467f, 0.168634f, -0.827549f,// 358
    -0.167277f, 0.167277f, -0.971616f,// 359
    -0.464385f, 0.464385f, -0.754117f,// 360
    -0.535467f, 0.168634f, -0.827549f,// 361
    -0.535467f, -0.168634f, -0.827549f,// 362
    -0.464385f, -0.464385f, -0.754117f,// 363
    -0.167277f, -0.167277f, -0.971616f,// 364
    -0.535467f, -0.168634f, -0.827549f,// 365
    0.168634f, 0.535467f, -0.827549f,// 366
    0.167277f, 0.167277f, -0.971616f,// 367
    0.464385f, 0.464385f, -0.754117f,// 368
    0.168634f, 0.535467f, -0.827549f,// 369
    -0.168634f, 0.535467f, -0.827549f,// 370
    -0.464385f, 0.464385f, -0.754117f,// 371
    -0.167277f, 0.167277f, -0.971616f,// 372
    -0.168634f, 0.535467f, -0.827549f // 373
  };
  static const unsigned short idx4[1152] = {// [1152]
    38, 86, 182,// 0
    86, 14, 182,// 1
    8, 86, 183,// 2
    86, 38, 183,// 3
    38, 87, 184,// 4
    87, 5, 184,// 5
    14, 87, 185,// 6
    87, 38, 185,// 7
    39, 88, 186,// 8
    88, 14, 186,// 9
    1, 88, 187,// 10
    88, 39, 187,// 11
    39, 89, 188,// 12
    89, 8, 188,// 13
    14, 89, 189,// 14
    89, 39, 189,// 15
    40, 90, 190,// 16
    90, 15, 190,// 17
    8, 90, 191,// 18
    90, 40, 191,// 19
    40, 91, 192,// 20
    91, 4, 192,// 21
    15, 91, 193,// 22
    91, 40, 193,// 23
    41, 92, 194,// 24
    92, 15, 194,// 25
    5, 92, 195,// 26
    92, 41, 195,// 27
    41, 93, 196,// 28
    93, 8, 196,// 29
    15, 93, 197,// 30
    93, 41, 197,// 31
    42, 94, 198,// 32
    94, 16, 198,// 33
    8, 94, 199,// 34
    94, 42, 199,// 35
    42, 95, 200,// 36
    95, 0, 200,// 37
    16, 95, 201,// 38
    95, 42, 201,// 39
    43, 96, 202,// 40
    96, 16, 202,// 41
    4, 96, 203,// 42
    96, 43, 203,// 43
    43, 97, 204,// 44
    97, 8, 204,// 45
    16, 97, 205,// 46
    97, 43, 205,// 47
    44, 98, 206,// 48
    98, 17, 206,// 49
    8, 98, 207,// 50
    98, 44, 207,// 51
    44, 99, 208,// 52
    99, 1, 208,// 53
    17, 99, 209,// 54
    99, 44, 209,// 55
    45, 100, 210,// 56
    100, 17, 210,// 57
    0, 100, 211,// 58
    100, 45, 211,// 59
    45, 101, 212,// 60
    101, 8, 212,// 61
    17, 101, 213,// 62
    101, 45, 213,// 63
    46, 102, 214,// 64
    102, 18, 214,// 65
    9, 102, 215,// 66
    102, 46, 215,// 67
    46, 103, 216,// 68
    103, 5, 216,// 69
    18, 103, 217,// 70
    103, 46, 217,// 71
    47, 104, 218,// 72
    104, 18, 218,// 73
    7, 104, 219,// 74
    104, 47, 219,// 75
    47, 105, 220,// 76
    105, 9, 220,// 77
    18, 105, 221,// 78
    105, 47, 221,// 79
    48, 106, 222,// 80
    106, 19, 222,// 81
    9, 106, 223,// 82
    106, 48, 223,// 83
    48, 107, 224,// 84
    107, 1, 224,// 85
    19, 107, 225,// 86
    107, 48, 225,// 87
    49, 108, 226,// 88
    108, 19, 226,// 89
    5, 108, 227,// 90
    108, 49, 227,// 91
    49, 109, 228,// 92
    109, 9, 228,// 93
    19, 109, 229,// 94
    109, 49, 229,// 95
    50, 110, 230,// 96
    110, 20, 230,// 97
    9, 110, 231,// 98
    110, 50, 231,// 99
    50, 111, 232,// 100
    111, 3, 232,// 101
    20, 111, 233,// 102
    111, 50, 233,// 103
    51, 112, 234,// 104
    112, 20, 234,// 105
    1, 112, 235,// 106
    112, 51, 235,// 107
    51, 113, 236,// 108
    113, 9, 236,// 109
    20, 113, 237,// 110
    113, 51, 237,// 111
    52, 114, 238,// 112
    114, 21, 238,// 113
    9, 114, 239,// 114
    114, 52, 239,// 115
    52, 115, 240,// 116
    115, 7, 240,// 117
    21, 115, 241,// 118
    115, 52, 241,// 119
    53, 116, 242,// 120
    116, 21, 242,// 121
    3, 116, 243,// 122
    116, 53, 243,// 123
    53, 117, 244,// 124
    117, 9, 244,// 125
    21, 117, 245,// 126
    117, 53, 245,// 127
    54, 118, 246,// 128
    118, 22, 246,// 129
    10, 118, 247,// 130
    118, 54, 247,// 131
    54, 119, 248,// 132
    119, 7, 248,// 133
    22, 119, 249,// 134
    119, 54, 249,// 135
    55, 120, 250,// 136
    120, 22, 250,// 137
    6, 120, 251,// 138
    120, 55, 251,// 139
    55, 121, 252,// 140
    121, 10, 252,// 141
    22, 121, 253,// 142
    121, 55, 253,// 143
    56, 122, 254,// 144
    122, 23, 254,// 145
    10, 122, 255,// 146
    122, 56, 255,// 147
    56, 123, 256,// 148
    123, 3, 256,// 149
    23, 123, 257,// 150
    123, 56, 257,// 151
    57, 124, 258,// 152
    124, 23, 258,// 153
    7, 124, 259,// 154
    124, 57, 259,// 155
    57, 125, 260,// 156
    125, 10, 260,// 157
    23, 125, 261,// 158
    125, 57, 261,// 159
    58, 126, 262,// 160
    126, 24, 262,// 161
    10, 126, 263,// 162
    126, 58, 263,// 163
    58, 127, 264,// 164
    127, 2, 264,// 165
    24, 127, 265,// 166
    127, 58, 265,// 167
    59, 128, 266,// 168
    128, 24, 266,// 169
    3, 128, 267,// 170
    128, 59, 267,// 171
    59, 129, 268,// 172
    129, 10, 268,// 173
    24, 129, 269,// 174
    129, 59, 269,// 175
    60, 130, 270,// 176
    130, 25, 270,// 177
    10, 130, 271,// 178
    130, 60, 271,// 179
    60, 131, 272,// 180
    131, 6, 272,// 181
    25, 131, 273,// 182
    131, 60, 273,// 183
    61, 132, 274,// 184
    132, 25, 274,// 185
    2, 132, 275,// 186
    132, 61, 275,// 187
    61, 133, 276,// 188
    133, 10, 276,// 189
    25, 133, 277,// 190
    133, 61, 277,// 191
    62, 134, 278,// 192
    134, 26, 278,// 193
    11, 134, 279,// 194
    134, 62, 279,// 195
    62, 135, 280,// 196
    135, 3, 280,// 197
    26, 135, 281,// 198
    135, 62, 281,// 199
    63, 136, 282,// 200
    136, 26, 282,// 201
    2, 136, 283,// 202
    136, 63, 283,// 203
    63, 137, 284,// 204
    137, 11, 284,// 205
    26, 137, 285,// 206
    137, 63, 285,// 207
    64, 138, 286,// 208
    138, 27, 286,// 209
    11, 138, 287,// 210
    138, 64, 287,// 211
    64, 139, 288,// 212
    139, 1, 288,// 213
    27, 139, 289,// 214
    139, 64, 289,// 215
    65, 140, 290,// 216
    140, 27, 290,// 217
    3, 140, 291,// 218
    140, 65, 291,// 219
    65, 141, 292,// 220
    141, 11, 292,// 221
    27, 141, 293,// 222
    141, 65, 293,// 223
    66, 142, 294,// 224
    142, 28, 294,// 225
    11, 142, 295,// 226
    142, 66, 295,// 227
    66, 143, 296,// 228
    143, 0, 296,// 229
    28, 143, 297,// 230
    143, 66, 297,// 231
    67, 144, 298,// 232
    144, 28, 298,// 233
    1, 144, 299,// 234
    144, 67, 299,// 235
    67, 145, 300,// 236
    145, 11, 300,// 237
    28, 145, 301,// 238
    145, 67, 301,// 239
    68, 146, 302,// 240
    146, 29, 302,// 241
    11, 146, 303,// 242
    146, 68, 303,// 243
    68, 147, 304,// 244
    147, 2, 304,// 245
    29, 147, 305,// 246
    147, 68, 305,// 247
    69, 148, 306,// 248
    148, 29, 306,// 249
    0, 148, 307,// 250
    148, 69, 307,// 251
    69, 149, 308,// 252
    149, 11, 308,// 253
    29, 149, 309,// 254
    149, 69, 309,// 255
    70, 150, 310,// 256
    150, 30, 310,// 257
    12, 150, 311,// 258
    150, 70, 311,// 259
    70, 151, 312,// 260
    151, 4, 312,// 261
    30, 151, 313,// 262
    151, 70, 313,// 263
    71, 152, 314,// 264
    152, 30, 314,// 265
    0, 152, 315,// 266
    152, 71, 315,// 267
    71, 153, 316,// 268
    153, 12, 316,// 269
    30, 153, 317,// 270
    153, 71, 317,// 271
    72, 154, 318,// 272
    154, 31, 318,// 273
    12, 154, 319,// 274
    154, 72, 319,// 275
    72, 155, 320,// 276
    155, 6, 320,// 277
    31, 155, 321,// 278
    155, 72, 321,// 279
    73, 156, 322,// 280
    156, 31, 322,// 281
    4, 156, 323,// 282
    156, 73, 323,// 283
    73, 157, 324,// 284
    157, 12, 324,// 285
    31, 157, 325,// 286
    157, 73, 325,// 287
    74, 158, 326,// 288
    158, 32, 326,// 289
    12, 158, 327,// 290
    158, 74, 327,// 291
    74, 159, 328,// 292
    159, 2, 328,// 293
    32, 159, 329,// 294
    159, 74, 329,// 295
    75, 160, 330,// 296
    160, 32, 330,// 297
    6, 160, 331,// 298
    160, 75, 331,// 299
    75, 161, 332,// 300
    161, 12, 332,// 301
    32, 161, 333,// 302
    161, 75, 333,// 303
    76, 162, 334,// 304
    162, 33, 334,// 305
    12, 162, 335,// 306
    162, 76, 335,// 307
    76, 163, 336,// 308
    163, 0, 336,// 309
    33, 163, 337,// 310
    163, 76, 337,// 311
    77, 164, 338,// 312
    164, 33, 338,// 313
    2, 164, 339,// 314
    164, 77, 339,// 315
    77, 165, 340,// 316
    165, 12, 340,// 317
    33, 165, 341,// 318
    165, 77, 341,// 319
    78, 166, 342,// 320
    166, 34, 342,// 321
    13, 166, 343,// 322
    166, 78, 343,// 323
    78, 167, 344,// 324
    167, 7, 344,// 325
    34, 167, 345,// 326
    167, 78, 345,// 327
    79, 168, 346,// 328
    168, 34, 346,// 329
    5, 168, 347,// 330
    168, 79, 347,// 331
    79, 169, 348,// 332
    169, 13, 348,// 333
    34, 169, 349,// 334
    169, 79, 349,// 335
    80, 170, 350,// 336
    170, 35, 350,// 337
    13, 170, 351,// 338
    170, 80, 351,// 339
    80, 171, 352,// 340
    171, 6, 352,// 341
    35, 171, 353,// 342
    171, 80, 353,// 343
    81, 172, 354,// 344
    172, 35, 354,// 345
    7, 172, 355,// 346
    172, 81, 355,// 347
    81, 173, 356,// 348
    173, 13, 356,// 349
    35, 173, 357,// 350
    173, 81, 357,// 351
    82, 174, 358,// 352
    174, 36, 358,// 353
    13, 174, 359,// 354
    174, 82, 359,// 355
    82, 175, 360,// 356
    175, 4, 360,// 357
    36, 175, 361,// 358
    175, 82, 361,// 359
    83, 176, 362,// 360
    176, 36, 362,// 361
    6, 176, 363,// 362
    176, 83, 363,// 363
    83, 177, 364,// 364
    177, 13, 364,// 365
    36, 177, 365,// 366
    177, 83, 365,// 367
    84, 178, 366,// 368
    178, 37, 366,// 369
    13, 178, 367,// 370
    178, 84, 367,// 371
    84, 179, 368,// 372
    179, 5, 368,// 373
    37, 179, 369,// 374
    179, 84, 369,// 375
    85, 180, 370,// 376
    180, 37, 370,// 377
    4, 180, 371,// 378
    180, 85, 371,// 379
    85, 181, 372,// 380
    181, 13, 372,// 381
    37, 181, 373,// 382
    181, 85, 373 // 383
  };
  glPushMatrix();
  glScaled(r,r,r);
  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, mCubeVerticesData);
  glEnableClientState(GL_NORMAL_ARRAY);
  glNormalPointer(GL_FLOAT, 0, mCubeVerticesData);
  glDrawElements(GL_TRIANGLES, 1152, GL_UNSIGNED_SHORT, idx4);
  glDisableClientState(GL_VERTEX_ARRAY);
  glDisableClientState(GL_NORMAL_ARRAY);
  glPopMatrix();

}

void molekul::ellipse(int style){
  if (style&ATOM_STYLE_WALLS){
    glEnable(GL_ALPHA_TEST);
    glDisable(GL_CULL_FACE);
    glBindTexture(GL_TEXTURE_2D, adpwall);
    glEnable(GL_TEXTURE_2D);
    glBegin(GL_QUADS);
    glNormal3f(-1.0,0,0);

    glTexCoord2d(0,0);
    glVertex3f(0.0,-1.0,-1.0);
    glTexCoord2d(0,1);
    glVertex3f(0.0,-1.0, 1.0);
    glTexCoord2d(1,1);
    glVertex3f(0.0, 1.0, 1.0);
    glTexCoord2d(1,0);
    glVertex3f(0.0, 1.0,-1.0);

    glNormal3f(0.0,-1,0);
    glTexCoord2d(0,0);
    glVertex3f(-1.0,0.0,-1.0);
    glTexCoord2d(0,1);
    glVertex3f(-1.0,0.0, 1.0);
    glTexCoord2d(1,1);
    glVertex3f( 1.0,0.0, 1.0);
    glTexCoord2d(1,0);
    glVertex3f( 1.0,0.0,-1.0);

    glNormal3f(0.0,0,-1);
    glTexCoord2d(0,0);
    glVertex3f(-1.0,-1.0,0.0);
    glTexCoord2d(0,1);
    glVertex3f(-1.0, 1.0,0.0);
    glTexCoord2d(1,1);
    glVertex3f( 1.0, 1.0,0.0);
    glTexCoord2d(1,0);
    glVertex3f( 1.0,-1.0,0.0);
    glEnd();
    glDisable(GL_TEXTURE_2D);  
  }
  glEnable(GL_CULL_FACE);
  if ((style&ATOM_STYLE_SOLID)&& ( style&ATOM_STYLE_SPHERE)){
    GLUquadricObj *q = gluNewQuadric();
    gluQuadricNormals(q, GL_SMOOTH);   

    if (LOD!=3) gluSphere(q,0.96,4*LOD,9*LOD);  
    else sp(0.96);
  }
  if (style&ATOM_STYLE_RINGS){
    if (style&ATOM_STYLE_WHITERING) glColor3f(1,1,1);
    else glColor3f(0,0,0);
    glBegin(GL_TRIANGLE_STRIP);
    glNormal3f( 0.0000000,  1.0000000,  0.0000000);//1
    glVertex3f( 0.0000000,  1.0000000,  0.0000000);//1
    glNormal3f( 0.0000000,  0.9848078, -0.0736482);//1
    glVertex3f( 0.0000000,  0.9848078, -0.0736482);//2
    glNormal3f( 0.3420201,  0.9396926,  0.0000000);//1
    glVertex3f( 0.3420201,  0.9396926,  0.0000000);//1
    glNormal3f( 0.3368241,  0.9254166, -0.0736482);//1
    glVertex3f( 0.3368241,  0.9254166, -0.0736482);//2
    glNormal3f( 0.6427876,  0.7660444,  0.0000000);//1
    glVertex3f( 0.6427876,  0.7660444,  0.0000000);//1
    glNormal3f( 0.6330222,  0.7544065, -0.0736482);//1
    glVertex3f( 0.6330222,  0.7544065, -0.0736482);//2
    glNormal3f( 0.8660254,  0.5000000,  0.0000000);//1
    glVertex3f( 0.8660254,  0.5000000,  0.0000000);//1
    glNormal3f( 0.8528685,  0.4924039, -0.0736482);//1
    glVertex3f( 0.8528685,  0.4924039, -0.0736482);//2
    glNormal3f( 0.9848078,  0.0736482,  0.0000000);//1
    glVertex3f( 0.9848078,  0.0736482,  0.0000000);//1
    glNormal3f( 0.9698463,  0.1710101, -0.0736482);//1
    glVertex3f( 0.9698463,  0.1710101, -0.0736482);//2
    glNormal3f( 0.9848078, -0.0736482,  0.0000000);//1
    glVertex3f( 0.9848078, -0.0736482,  0.0000000);//1
    glNormal3f( 0.9698463, -0.1710101, -0.0736482);//1
    glVertex3f( 0.9698463, -0.1710101, -0.0736482);//2
    glNormal3f( 0.8660254, -0.5000000,  0.0000000);//1
    glVertex3f( 0.8660254, -0.5000000,  0.0000000);//1
    glNormal3f( 0.8528685, -0.4924039, -0.0736482);//1
    glVertex3f( 0.8528685, -0.4924039, -0.0736482);//2
    glNormal3f( 0.6427876, -0.7660444,  0.0000000);//1
    glVertex3f( 0.6427876, -0.7660444,  0.0000000);//1
    glNormal3f( 0.6330222, -0.7544065, -0.0736482);//1
    glVertex3f( 0.6330222, -0.7544065, -0.0736482);//2
    glNormal3f( 0.3420201, -0.9396926,  0.0000000);//1
    glVertex3f( 0.3420201, -0.9396926,  0.0000000);//1
    glNormal3f( 0.3368241, -0.9254166, -0.0736482);//1
    glVertex3f( 0.3368241, -0.9254166, -0.0736482);//2
    glNormal3f( 0.0000000, -1.0000000,  0.0000000);//1
    glVertex3f( 0.0000000, -1.0000000,  0.0000000);//1
    glNormal3f( 0.0000000, -0.9848078, -0.0736482);//1
    glVertex3f( 0.0000000, -0.9848078, -0.0736482);//2
    glNormal3f(-0.3420201, -0.9396926,  0.0000000);//1
    glVertex3f(-0.3420201, -0.9396926,  0.0000000);//1
    glNormal3f(-0.3368241, -0.9254166, -0.0736482);//1
    glVertex3f(-0.3368241, -0.9254166, -0.0736482);//2
    glNormal3f(-0.6427876, -0.7660444,  0.0000000);//1
    glVertex3f(-0.6427876, -0.7660444,  0.0000000);//1
    glNormal3f(-0.6330222, -0.7544065, -0.0736482);//1
    glVertex3f(-0.6330222, -0.7544065, -0.0736482);//2
    glNormal3f(-0.8660254, -0.5000000,  0.0000000);//1
    glVertex3f(-0.8660254, -0.5000000,  0.0000000);//1
    glNormal3f(-0.8528685, -0.4924039, -0.0736482);//1
    glVertex3f(-0.8528685, -0.4924039, -0.0736482);//2
    glNormal3f(-0.9848078, -0.0736482,  0.0000000);//1
    glVertex3f(-0.9848078, -0.0736482,  0.0000000);//1
    glNormal3f(-0.9698463, -0.1710101, -0.0736482);//1
    glVertex3f(-0.9698463, -0.1710101, -0.0736482);//2
    glNormal3f(-0.9848078,  0.0736482,  0.0000000);//1
    glVertex3f(-0.9848078,  0.0736482,  0.0000000);//1
    glNormal3f(-0.9698463,  0.1710101, -0.0736482);//1
    glVertex3f(-0.9698463,  0.1710101, -0.0736482);//2
    glNormal3f(-0.8660254,  0.5000000,  0.0000000);//1
    glVertex3f(-0.8660254,  0.5000000,  0.0000000);//1
    glNormal3f(-0.8528685,  0.4924039, -0.0736482);//1
    glVertex3f(-0.8528685,  0.4924039, -0.0736482);//2
    glNormal3f(-0.6427876,  0.7660444,  0.0000000);//1
    glVertex3f(-0.6427876,  0.7660444,  0.0000000);//1
    glNormal3f(-0.6330222,  0.7544065, -0.0736482);//1
    glVertex3f(-0.6330222,  0.7544065, -0.0736482);//2
    glNormal3f(-0.3420201,  0.9396926,  0.0000000);//1
    glVertex3f(-0.3420201,  0.9396926,  0.0000000);//1
    glNormal3f(-0.3368241,  0.9254166, -0.0736482);//1
    glVertex3f(-0.3368241,  0.9254166, -0.0736482);//2
    glNormal3f( 0.0000000,  1.0000000,  0.0000000);//1
    glVertex3f( 0.0000000,  1.0000000,  0.0000000);//1
    glNormal3f( 0.0000000,  0.9848078, -0.0736482);//1
    glVertex3f( 0.0000000,  0.9848078, -0.0736482);//2


    glNormal3f( 0.0000000,  1.0000000, 0.0000000);//1
    glVertex3f( 0.0000000,  1.0000000, 0.0000000);//1
    glNormal3f( 0.0000000,  0.9848078, 0.0736482);//1
    glVertex3f( 0.0000000,  0.9848078, 0.0736482);//2
    glNormal3f( 0.3420201,  0.9396926, 0.0000000);//1
    glVertex3f( 0.3420201,  0.9396926, 0.0000000);//1
    glNormal3f( 0.3368241,  0.9254166, 0.0736482);//1
    glVertex3f( 0.3368241,  0.9254166, 0.0736482);//2
    glNormal3f( 0.6427876,  0.7660444, 0.0000000);//1
    glVertex3f( 0.6427876,  0.7660444, 0.0000000);//1
    glNormal3f( 0.6330222,  0.7544065, 0.0736482);//1
    glVertex3f( 0.6330222,  0.7544065, 0.0736482);//2
    glNormal3f( 0.8660254,  0.5000000, 0.0000000);//1
    glVertex3f( 0.8660254,  0.5000000, 0.0000000);//1
    glNormal3f( 0.8528685,  0.4924039, 0.0736482);//1
    glVertex3f( 0.8528685,  0.4924039, 0.0736482);//2
    glNormal3f( 0.9848078,  0.0736482, 0.0000000);//1
    glVertex3f( 0.9848078,  0.0736482, 0.0000000);//1
    glNormal3f( 0.9698463,  0.1710101, 0.0736482);//1
    glVertex3f( 0.9698463,  0.1710101, 0.0736482);//2
    glNormal3f( 0.9848078, -0.0736482, 0.0000000);//1
    glVertex3f( 0.9848078, -0.0736482, 0.0000000);//1
    glNormal3f( 0.9698463, -0.1710101, 0.0736482);//1
    glVertex3f( 0.9698463, -0.1710101, 0.0736482);//2
    glNormal3f( 0.8660254, -0.5000000, 0.0000000);//1
    glVertex3f( 0.8660254, -0.5000000, 0.0000000);//1
    glNormal3f( 0.8528685, -0.4924039, 0.0736482);//1
    glVertex3f( 0.8528685, -0.4924039, 0.0736482);//2
    glNormal3f( 0.6427876, -0.7660444, 0.0000000);//1
    glVertex3f( 0.6427876, -0.7660444, 0.0000000);//1
    glNormal3f( 0.6330222, -0.7544065, 0.0736482);//1
    glVertex3f( 0.6330222, -0.7544065, 0.0736482);//2
    glNormal3f( 0.3420201, -0.9396926, 0.0000000);//1
    glVertex3f( 0.3420201, -0.9396926, 0.0000000);//1
    glNormal3f( 0.3368241, -0.9254166, 0.0736482);//1
    glVertex3f( 0.3368241, -0.9254166, 0.0736482);//2
    glNormal3f( 0.0000000, -1.0000000, 0.0000000);//1
    glVertex3f( 0.0000000, -1.0000000, 0.0000000);//1
    glNormal3f( 0.0000000, -0.9848078, 0.0736482);//1
    glVertex3f( 0.0000000, -0.9848078, 0.0736482);//2
    glNormal3f(-0.3420201, -0.9396926, 0.0000000);//1
    glVertex3f(-0.3420201, -0.9396926, 0.0000000);//1
    glNormal3f(-0.3368241, -0.9254166, 0.0736482);//1
    glVertex3f(-0.3368241, -0.9254166, 0.0736482);//2
    glNormal3f(-0.6427876, -0.7660444, 0.0000000);//1
    glVertex3f(-0.6427876, -0.7660444, 0.0000000);//1
    glNormal3f(-0.6330222, -0.7544065, 0.0736482);//1
    glVertex3f(-0.6330222, -0.7544065, 0.0736482);//2
    glNormal3f(-0.8660254, -0.5000000, 0.0000000);//1
    glVertex3f(-0.8660254, -0.5000000, 0.0000000);//1
    glNormal3f(-0.8528685, -0.4924039, 0.0736482);//1
    glVertex3f(-0.8528685, -0.4924039, 0.0736482);//2
    glNormal3f(-0.9848078, -0.0736482, 0.0000000);//1
    glVertex3f(-0.9848078, -0.0736482, 0.0000000);//1
    glNormal3f(-0.9698463, -0.1710101, 0.0736482);//1
    glVertex3f(-0.9698463, -0.1710101, 0.0736482);//2
    glNormal3f(-0.9848078,  0.0736482, 0.0000000);//1
    glVertex3f(-0.9848078,  0.0736482, 0.0000000);//1
    glNormal3f(-0.9698463,  0.1710101, 0.0736482);//1
    glVertex3f(-0.9698463,  0.1710101, 0.0736482);//2
    glNormal3f(-0.8660254,  0.5000000, 0.0000000);//1
    glVertex3f(-0.8660254,  0.5000000, 0.0000000);//1
    glNormal3f(-0.8528685,  0.4924039, 0.0736482);//1
    glVertex3f(-0.8528685,  0.4924039, 0.0736482);//2
    glNormal3f(-0.6427876,  0.7660444, 0.0000000);//1
    glVertex3f(-0.6427876,  0.7660444, 0.0000000);//1
    glNormal3f(-0.6330222,  0.7544065, 0.0736482);//1
    glVertex3f(-0.6330222,  0.7544065, 0.0736482);//2
    glNormal3f(-0.3420201,  0.9396926, 0.0000000);//1
    glVertex3f(-0.3420201,  0.9396926, 0.0000000);//1
    glNormal3f(-0.3368241,  0.9254166, 0.0736482);//1
    glVertex3f(-0.3368241,  0.9254166, 0.0736482);//2
    glNormal3f( 0.0000000,  1.0000000, 0.0000000);//1
    glVertex3f( 0.0000000,  1.0000000, 0.0000000);//1
    glNormal3f( 0.0000000,  0.9848078, 0.0736482);//1
    glVertex3f( 0.0000000,  0.9848078, 0.0736482);//2

    glEnd();

    glBegin(GL_TRIANGLE_STRIP);
    glNormal3f(  0.0000000, 0.0000000,  1.0000000);//1
    glVertex3f(  0.0000000, 0.0000000,  1.0000000);//1
    glNormal3f( -0.0736482, 0.0000000,  0.9848078);//1
    glVertex3f( -0.0736482, 0.0000000,  0.9848078);//2
    glNormal3f(  0.0000000, 0.3420201,  0.9396926);//1
    glVertex3f(  0.0000000, 0.3420201,  0.9396926);//1
    glNormal3f( -0.0736482, 0.3368241,  0.9254166);//1
    glVertex3f( -0.0736482, 0.3368241,  0.9254166);//2
    glNormal3f(  0.0000000, 0.6427876,  0.7660444);//1
    glVertex3f(  0.0000000, 0.6427876,  0.7660444);//1
    glNormal3f( -0.0736482, 0.6330222,  0.7544065);//1
    glVertex3f( -0.0736482, 0.6330222,  0.7544065);//2
    glNormal3f(  0.0000000, 0.8660254,  0.5000000);//1
    glVertex3f(  0.0000000, 0.8660254,  0.5000000);//1
    glNormal3f( -0.0736482, 0.8528685,  0.4924039);//1
    glVertex3f( -0.0736482, 0.8528685,  0.4924039);//2
    glNormal3f(  0.0000000, 0.9848078,  0.0736482);//1
    glVertex3f(  0.0000000, 0.9848078,  0.0736482);//1
    glNormal3f( -0.0736482, 0.9698463,  0.1710101);//1
    glVertex3f( -0.0736482, 0.9698463,  0.1710101);//2
    glNormal3f(  0.0000000, 0.9848078, -0.0736482);//1
    glVertex3f(  0.0000000, 0.9848078, -0.0736482);//1
    glNormal3f( -0.0736482, 0.9698463, -0.1710101);//1
    glVertex3f( -0.0736482, 0.9698463, -0.1710101);//2
    glNormal3f(  0.0000000, 0.8660254, -0.5000000);//1
    glVertex3f(  0.0000000, 0.8660254, -0.5000000);//1
    glNormal3f( -0.0736482, 0.8528685, -0.4924039);//1
    glVertex3f( -0.0736482, 0.8528685, -0.4924039);//2
    glNormal3f(  0.0000000, 0.6427876, -0.7660444);//1
    glVertex3f(  0.0000000, 0.6427876, -0.7660444);//1
    glNormal3f( -0.0736482, 0.6330222, -0.7544065);//1
    glVertex3f( -0.0736482, 0.6330222, -0.7544065);//2
    glNormal3f(  0.0000000, 0.3420201, -0.9396926);//1
    glVertex3f(  0.0000000, 0.3420201, -0.9396926);//1
    glNormal3f( -0.0736482, 0.3368241, -0.9254166);//1
    glVertex3f( -0.0736482, 0.3368241, -0.9254166);//2
    glNormal3f(  0.0000000, 0.0000000, -1.0000000);//1
    glVertex3f(  0.0000000, 0.0000000, -1.0000000);//1
    glNormal3f( -0.0736482, 0.0000000, -0.9848078);//1
    glVertex3f( -0.0736482, 0.0000000, -0.9848078);//2
    glNormal3f(  0.0000000,-0.3420201, -0.9396926);//1
    glVertex3f(  0.0000000,-0.3420201, -0.9396926);//1
    glNormal3f( -0.0736482,-0.3368241, -0.9254166);//1
    glVertex3f( -0.0736482,-0.3368241, -0.9254166);//2
    glNormal3f(  0.0000000,-0.6427876, -0.7660444);//1
    glVertex3f(  0.0000000,-0.6427876, -0.7660444);//1
    glNormal3f( -0.0736482,-0.6330222, -0.7544065);//1
    glVertex3f( -0.0736482,-0.6330222, -0.7544065);//2
    glNormal3f(  0.0000000,-0.8660254, -0.5000000);//1
    glVertex3f(  0.0000000,-0.8660254, -0.5000000);//1
    glNormal3f( -0.0736482,-0.8528685, -0.4924039);//1
    glVertex3f( -0.0736482,-0.8528685, -0.4924039);//2
    glNormal3f(  0.0000000,-0.9848078, -0.0736482);//1
    glVertex3f(  0.0000000,-0.9848078, -0.0736482);//1
    glNormal3f( -0.0736482,-0.9698463, -0.1710101);//1
    glVertex3f( -0.0736482,-0.9698463, -0.1710101);//2
    glNormal3f(  0.0000000,-0.9848078,  0.0736482);//1
    glVertex3f(  0.0000000,-0.9848078,  0.0736482);//1
    glNormal3f( -0.0736482,-0.9698463,  0.1710101);//1
    glVertex3f( -0.0736482,-0.9698463,  0.1710101);//2
    glNormal3f(  0.0000000,-0.8660254,  0.5000000);//1
    glVertex3f(  0.0000000,-0.8660254,  0.5000000);//1
    glNormal3f( -0.0736482,-0.8528685,  0.4924039);//1
    glVertex3f( -0.0736482,-0.8528685,  0.4924039);//2
    glNormal3f(  0.0000000,-0.6427876,  0.7660444);//1
    glVertex3f(  0.0000000,-0.6427876,  0.7660444);//1
    glNormal3f( -0.0736482,-0.6330222,  0.7544065);//1
    glVertex3f( -0.0736482,-0.6330222,  0.7544065);//2
    glNormal3f(  0.0000000,-0.3420201,  0.9396926);//1
    glVertex3f(  0.0000000,-0.3420201,  0.9396926);//1
    glNormal3f( -0.0736482,-0.3368241,  0.9254166);//1
    glVertex3f( -0.0736482,-0.3368241,  0.9254166);//2
    glNormal3f(  0.0000000, 0.0000000,  1.0000000);//1
    glVertex3f(  0.0000000, 0.0000000,  1.0000000);//1
    glNormal3f( -0.0736482, 0.0000000,  0.9848078);//1
    glVertex3f( -0.0736482, 0.0000000,  0.9848078);//2

    glNormal3f( 0.0000000, 0.0000000,  1.0000000);//1
    glVertex3f( 0.0000000, 0.0000000,  1.0000000);//1
    glNormal3f( 0.0736482, 0.0000000,  0.9848078);//1
    glVertex3f( 0.0736482, 0.0000000,  0.9848078);//2
    glNormal3f( 0.0000000, 0.3420201,  0.9396926);//1
    glVertex3f( 0.0000000, 0.3420201,  0.9396926);//1
    glNormal3f( 0.0736482, 0.3368241,  0.9254166);//1
    glVertex3f( 0.0736482, 0.3368241,  0.9254166);//2
    glNormal3f( 0.0000000, 0.6427876,  0.7660444);//1
    glVertex3f( 0.0000000, 0.6427876,  0.7660444);//1
    glNormal3f( 0.0736482, 0.6330222,  0.7544065);//1
    glVertex3f( 0.0736482, 0.6330222,  0.7544065);//2
    glNormal3f( 0.0000000, 0.8660254,  0.5000000);//1
    glVertex3f( 0.0000000, 0.8660254,  0.5000000);//1
    glNormal3f( 0.0736482, 0.8528685,  0.4924039);//1
    glVertex3f( 0.0736482, 0.8528685,  0.4924039);//2
    glNormal3f( 0.0000000, 0.9848078,  0.0736482);//1
    glVertex3f( 0.0000000, 0.9848078,  0.0736482);//1
    glNormal3f( 0.0736482, 0.9698463,  0.1710101);//1
    glVertex3f( 0.0736482, 0.9698463,  0.1710101);//2
    glNormal3f( 0.0000000, 0.9848078, -0.0736482);//1
    glVertex3f( 0.0000000, 0.9848078, -0.0736482);//1
    glNormal3f( 0.0736482, 0.9698463, -0.1710101);//1
    glVertex3f( 0.0736482, 0.9698463, -0.1710101);//2
    glNormal3f( 0.0000000, 0.8660254, -0.5000000);//1
    glVertex3f( 0.0000000, 0.8660254, -0.5000000);//1
    glNormal3f( 0.0736482, 0.8528685, -0.4924039);//1
    glVertex3f( 0.0736482, 0.8528685, -0.4924039);//2
    glNormal3f( 0.0000000, 0.6427876, -0.7660444);//1
    glVertex3f( 0.0000000, 0.6427876, -0.7660444);//1
    glNormal3f( 0.0736482, 0.6330222, -0.7544065);//1
    glVertex3f( 0.0736482, 0.6330222, -0.7544065);//2
    glNormal3f( 0.0000000, 0.3420201, -0.9396926);//1
    glVertex3f( 0.0000000, 0.3420201, -0.9396926);//1
    glNormal3f( 0.0736482, 0.3368241, -0.9254166);//1
    glVertex3f( 0.0736482, 0.3368241, -0.9254166);//2
    glNormal3f( 0.0000000, 0.0000000, -1.0000000);//1
    glVertex3f( 0.0000000, 0.0000000, -1.0000000);//1
    glNormal3f( 0.0736482, 0.0000000, -0.9848078);//1
    glVertex3f( 0.0736482, 0.0000000, -0.9848078);//2
    glNormal3f( 0.0000000,-0.3420201, -0.9396926);//1
    glVertex3f( 0.0000000,-0.3420201, -0.9396926);//1
    glNormal3f( 0.0736482,-0.3368241, -0.9254166);//1
    glVertex3f( 0.0736482,-0.3368241, -0.9254166);//2
    glNormal3f( 0.0000000,-0.6427876, -0.7660444);//1
    glVertex3f( 0.0000000,-0.6427876, -0.7660444);//1
    glNormal3f( 0.0736482,-0.6330222, -0.7544065);//1
    glVertex3f( 0.0736482,-0.6330222, -0.7544065);//2
    glNormal3f( 0.0000000,-0.8660254, -0.5000000);//1
    glVertex3f( 0.0000000,-0.8660254, -0.5000000);//1
    glNormal3f( 0.0736482,-0.8528685, -0.4924039);//1
    glVertex3f( 0.0736482,-0.8528685, -0.4924039);//2
    glNormal3f( 0.0000000,-0.9848078, -0.0736482);//1
    glVertex3f( 0.0000000,-0.9848078, -0.0736482);//1
    glNormal3f( 0.0736482,-0.9698463, -0.1710101);//1
    glVertex3f( 0.0736482,-0.9698463, -0.1710101);//2
    glNormal3f( 0.0000000,-0.9848078,  0.0736482);//1
    glVertex3f( 0.0000000,-0.9848078,  0.0736482);//1
    glNormal3f( 0.0736482,-0.9698463,  0.1710101);//1
    glVertex3f( 0.0736482,-0.9698463,  0.1710101);//2
    glNormal3f( 0.0000000,-0.8660254,  0.5000000);//1
    glVertex3f( 0.0000000,-0.8660254,  0.5000000);//1
    glNormal3f( 0.0736482,-0.8528685,  0.4924039);//1
    glVertex3f( 0.0736482,-0.8528685,  0.4924039);//2
    glNormal3f( 0.0000000,-0.6427876,  0.7660444);//1
    glVertex3f( 0.0000000,-0.6427876,  0.7660444);//1
    glNormal3f( 0.0736482,-0.6330222,  0.7544065);//1
    glVertex3f( 0.0736482,-0.6330222,  0.7544065);//2
    glNormal3f( 0.0000000,-0.3420201,  0.9396926);//1
    glVertex3f( 0.0000000,-0.3420201,  0.9396926);//1
    glNormal3f( 0.0736482,-0.3368241,  0.9254166);//1
    glVertex3f( 0.0736482,-0.3368241,  0.9254166);//2
    glNormal3f( 0.0000000, 0.0000000,  1.0000000);//1
    glVertex3f( 0.0000000, 0.0000000,  1.0000000);//1
    glNormal3f( 0.0736482, 0.0000000,  0.9848078);//1
    glVertex3f( 0.0736482, 0.0000000,  0.9848078);//2

    glEnd();


    glBegin(GL_TRIANGLE_STRIP);
    glNormal3f( 0.0000000,  0.0000000,  1.0000000);//1
    glVertex3f( 0.0000000,  0.0000000,  1.0000000);//1
    glNormal3f( 0.0000000, -0.0736482,  0.9848078);//1
    glVertex3f( 0.0000000, -0.0736482,  0.9848078);//2
    glNormal3f( 0.3420201,  0.0000000,  0.9396926);//1
    glVertex3f( 0.3420201,  0.0000000,  0.9396926);//1
    glNormal3f( 0.3368241, -0.0736482,  0.9254166);//1
    glVertex3f( 0.3368241, -0.0736482,  0.9254166);//2
    glNormal3f( 0.6427876,  0.0000000,  0.7660444);//1
    glVertex3f( 0.6427876,  0.0000000,  0.7660444);//1
    glNormal3f( 0.6330222, -0.0736482,  0.7544065);//1
    glVertex3f( 0.6330222, -0.0736482,  0.7544065);//2
    glNormal3f( 0.8660254,  0.0000000,  0.5000000);//1
    glVertex3f( 0.8660254,  0.0000000,  0.5000000);//1
    glNormal3f( 0.8528685, -0.0736482,  0.4924039);//1
    glVertex3f( 0.8528685, -0.0736482,  0.4924039);//2
    glNormal3f( 0.9848078,  0.0000000,  0.0736482);//1
    glVertex3f( 0.9848078,  0.0000000,  0.0736482);//1
    glNormal3f( 0.9698463, -0.0736482,  0.1710101);//1
    glVertex3f( 0.9698463, -0.0736482,  0.1710101);//2
    glNormal3f( 0.9848078,  0.0000000, -0.0736482);//1
    glVertex3f( 0.9848078,  0.0000000, -0.0736482);//1
    glNormal3f( 0.9698463, -0.0736482, -0.1710101);//1
    glVertex3f( 0.9698463, -0.0736482, -0.1710101);//2
    glNormal3f( 0.8660254,  0.0000000, -0.5000000);//1
    glVertex3f( 0.8660254,  0.0000000, -0.5000000);//1
    glNormal3f( 0.8528685, -0.0736482, -0.4924039);//1
    glVertex3f( 0.8528685, -0.0736482, -0.4924039);//2
    glNormal3f( 0.6427876,  0.0000000, -0.7660444);//1
    glVertex3f( 0.6427876,  0.0000000, -0.7660444);//1
    glNormal3f( 0.6330222, -0.0736482, -0.7544065);//1
    glVertex3f( 0.6330222, -0.0736482, -0.7544065);//2
    glNormal3f( 0.3420201,  0.0000000, -0.9396926);//1
    glVertex3f( 0.3420201,  0.0000000, -0.9396926);//1
    glNormal3f( 0.3368241, -0.0736482, -0.9254166);//1
    glVertex3f( 0.3368241, -0.0736482, -0.9254166);//2
    glNormal3f( 0.0000000,  0.0000000, -1.0000000);//1
    glVertex3f( 0.0000000,  0.0000000, -1.0000000);//1
    glNormal3f( 0.0000000, -0.0736482, -0.9848078);//1
    glVertex3f( 0.0000000, -0.0736482, -0.9848078);//2
    glNormal3f(-0.3420201,  0.0000000, -0.9396926);//1
    glVertex3f(-0.3420201,  0.0000000, -0.9396926);//1
    glNormal3f(-0.3368241, -0.0736482, -0.9254166);//1
    glVertex3f(-0.3368241, -0.0736482, -0.9254166);//2
    glNormal3f(-0.6427876,  0.0000000, -0.7660444);//1
    glVertex3f(-0.6427876,  0.0000000, -0.7660444);//1
    glNormal3f(-0.6330222, -0.0736482, -0.7544065);//1
    glVertex3f(-0.6330222, -0.0736482, -0.7544065);//2
    glNormal3f(-0.8660254,  0.0000000, -0.5000000);//1
    glVertex3f(-0.8660254,  0.0000000, -0.5000000);//1
    glNormal3f(-0.8528685, -0.0736482, -0.4924039);//1
    glVertex3f(-0.8528685, -0.0736482, -0.4924039);//2
    glNormal3f(-0.9848078,  0.0000000, -0.0736482);//1
    glVertex3f(-0.9848078,  0.0000000, -0.0736482);//1
    glNormal3f(-0.9698463, -0.0736482, -0.1710101);//1
    glVertex3f(-0.9698463, -0.0736482, -0.1710101);//2
    glNormal3f(-0.9848078,  0.0000000,  0.0736482);//1
    glVertex3f(-0.9848078,  0.0000000,  0.0736482);//1
    glNormal3f(-0.9698463, -0.0736482,  0.1710101);//1
    glVertex3f(-0.9698463, -0.0736482,  0.1710101);//2
    glNormal3f(-0.8660254,  0.0000000,  0.5000000);//1
    glVertex3f(-0.8660254,  0.0000000,  0.5000000);//1
    glNormal3f(-0.8528685, -0.0736482,  0.4924039);//1
    glVertex3f(-0.8528685, -0.0736482,  0.4924039);//2
    glNormal3f(-0.6427876,  0.0000000,  0.7660444);//1
    glVertex3f(-0.6427876,  0.0000000,  0.7660444);//1
    glNormal3f(-0.6330222, -0.0736482,  0.7544065);//1
    glVertex3f(-0.6330222, -0.0736482,  0.7544065);//2
    glNormal3f(-0.3420201,  0.0000000,  0.9396926);//1
    glVertex3f(-0.3420201,  0.0000000,  0.9396926);//1
    glNormal3f(-0.3368241, -0.0736482,  0.9254166);//1
    glVertex3f(-0.3368241, -0.0736482,  0.9254166);//2
    glNormal3f( 0.0000000,  0.0000000,  1.0000000);//1
    glVertex3f( 0.0000000,  0.0000000,  1.0000000);//1
    glNormal3f( 0.0000000, -0.0736482,  0.9848078);//1
    glVertex3f( 0.0000000, -0.0736482,  0.9848078);//2

    glNormal3f( 0.0000000, 0.0000000,  1.0000000);//1
    glVertex3f( 0.0000000, 0.0000000,  1.0000000);//1
    glNormal3f( 0.0000000, 0.0736482,  0.9848078);//1
    glVertex3f( 0.0000000, 0.0736482,  0.9848078);//2
    glNormal3f( 0.3420201, 0.0000000,  0.9396926);//1
    glVertex3f( 0.3420201, 0.0000000,  0.9396926);//1
    glNormal3f( 0.3368241, 0.0736482,  0.9254166);//1
    glVertex3f( 0.3368241, 0.0736482,  0.9254166);//2
    glNormal3f( 0.6427876, 0.0000000,  0.7660444);//1
    glVertex3f( 0.6427876, 0.0000000,  0.7660444);//1
    glNormal3f( 0.6330222, 0.0736482,  0.7544065);//1
    glVertex3f( 0.6330222, 0.0736482,  0.7544065);//2
    glNormal3f( 0.8660254, 0.0000000,  0.5000000);//1
    glVertex3f( 0.8660254, 0.0000000,  0.5000000);//1
    glNormal3f( 0.8528685, 0.0736482,  0.4924039);//1
    glVertex3f( 0.8528685, 0.0736482,  0.4924039);//2
    glNormal3f( 0.9848078, 0.0000000,  0.0736482);//1
    glVertex3f( 0.9848078, 0.0000000,  0.0736482);//1
    glNormal3f( 0.9698463, 0.0736482,  0.1710101);//1
    glVertex3f( 0.9698463, 0.0736482,  0.1710101);//2
    glNormal3f( 0.9848078, 0.0000000, -0.0736482);//1
    glVertex3f( 0.9848078, 0.0000000, -0.0736482);//1
    glNormal3f( 0.9698463, 0.0736482, -0.1710101);//1
    glVertex3f( 0.9698463, 0.0736482, -0.1710101);//2
    glNormal3f( 0.8660254, 0.0000000, -0.5000000);//1
    glVertex3f( 0.8660254, 0.0000000, -0.5000000);//1
    glNormal3f( 0.8528685, 0.0736482, -0.4924039);//1
    glVertex3f( 0.8528685, 0.0736482, -0.4924039);//2
    glNormal3f( 0.6427876, 0.0000000, -0.7660444);//1
    glVertex3f( 0.6427876, 0.0000000, -0.7660444);//1
    glNormal3f( 0.6330222, 0.0736482, -0.7544065);//1
    glVertex3f( 0.6330222, 0.0736482, -0.7544065);//2
    glNormal3f( 0.3420201, 0.0000000, -0.9396926);//1
    glVertex3f( 0.3420201, 0.0000000, -0.9396926);//1
    glNormal3f( 0.3368241, 0.0736482, -0.9254166);//1
    glVertex3f( 0.3368241, 0.0736482, -0.9254166);//2
    glNormal3f( 0.0000000, 0.0000000, -1.0000000);//1
    glVertex3f( 0.0000000, 0.0000000, -1.0000000);//1
    glNormal3f( 0.0000000, 0.0736482, -0.9848078);//1
    glVertex3f( 0.0000000, 0.0736482, -0.9848078);//2
    glNormal3f(-0.3420201, 0.0000000, -0.9396926);//1
    glVertex3f(-0.3420201, 0.0000000, -0.9396926);//1
    glNormal3f(-0.3368241, 0.0736482, -0.9254166);//1
    glVertex3f(-0.3368241, 0.0736482, -0.9254166);//2
    glNormal3f(-0.6427876, 0.0000000, -0.7660444);//1
    glVertex3f(-0.6427876, 0.0000000, -0.7660444);//1
    glNormal3f(-0.6330222, 0.0736482, -0.7544065);//1
    glVertex3f(-0.6330222, 0.0736482, -0.7544065);//2
    glNormal3f(-0.8660254, 0.0000000, -0.5000000);//1
    glVertex3f(-0.8660254, 0.0000000, -0.5000000);//1
    glNormal3f(-0.8528685, 0.0736482, -0.4924039);//1
    glVertex3f(-0.8528685, 0.0736482, -0.4924039);//2
    glNormal3f(-0.9848078, 0.0000000, -0.0736482);//1
    glVertex3f(-0.9848078, 0.0000000, -0.0736482);//1
    glNormal3f(-0.9698463, 0.0736482, -0.1710101);//1
    glVertex3f(-0.9698463, 0.0736482, -0.1710101);//2
    glNormal3f(-0.9848078, 0.0000000,  0.0736482);//1
    glVertex3f(-0.9848078, 0.0000000,  0.0736482);//1
    glNormal3f(-0.9698463, 0.0736482,  0.1710101);//1
    glVertex3f(-0.9698463, 0.0736482,  0.1710101);//2
    glNormal3f(-0.8660254, 0.0000000,  0.5000000);//1
    glVertex3f(-0.8660254, 0.0000000,  0.5000000);//1
    glNormal3f(-0.8528685, 0.0736482,  0.4924039);//1
    glVertex3f(-0.8528685, 0.0736482,  0.4924039);//2
    glNormal3f(-0.6427876, 0.0000000,  0.7660444);//1
    glVertex3f(-0.6427876, 0.0000000,  0.7660444);//1
    glNormal3f(-0.6330222, 0.0736482,  0.7544065);//1
    glVertex3f(-0.6330222, 0.0736482,  0.7544065);//2
    glNormal3f(-0.3420201, 0.0000000,  0.9396926);//1
    glVertex3f(-0.3420201, 0.0000000,  0.9396926);//1
    glNormal3f(-0.3368241, 0.0736482,  0.9254166);//1
    glVertex3f(-0.3368241, 0.0736482,  0.9254166);//2
    glNormal3f( 0.0000000, 0.0000000,  1.0000000);//1
    glVertex3f( 0.0000000, 0.0000000,  1.0000000);//1
    glNormal3f( 0.0000000, 0.0736482,  0.9848078);//1
    glVertex3f( 0.0000000, 0.0736482,  0.9848078);//2

    glEnd();
  }
}
void molekul::dodecaeder(GLfloat r){
  static const GLfloat dodev[324]={
    0.000000, -0.618034,  1.618034,  1.000000, -1.000000,  1.000000,  1.618034,  0.000000,  0.618034,
    0.000000, -0.618034,  1.618034,  1.618034,  0.000000,  0.618034,  1.000000,  1.000000,  1.000000,
    0.000000, -0.618034,  1.618034,  1.000000,  1.000000,  1.000000,  0.000000,  0.618034,  1.618034,
    0.000000,  0.618034,  1.618034, -1.000000,  1.000000,  1.000000, -1.618034,  0.000000,  0.618034,
    0.000000,  0.618034,  1.618034, -1.618034,  0.000000,  0.618034, -1.000000, -1.000000,  1.000000,
    0.000000,  0.618034,  1.618034, -1.000000, -1.000000,  1.000000,  0.000000, -0.618034,  1.618034,
    0.000000,  0.618034,  1.618034,  1.000000,  1.000000,  1.000000,  0.618034,  1.618034,  0.000000,
    0.000000,  0.618034,  1.618034,  0.618034,  1.618034,  0.000000, -0.618034,  1.618034,  0.000000,
    0.000000,  0.618034,  1.618034, -0.618034,  1.618034,  0.000000, -1.000000,  1.000000,  1.000000,
    1.000000,  1.000000,  1.000000,  1.618034,  0.000000,  0.618034,  1.618034,  0.000000, -0.618034,
    1.000000,  1.000000,  1.000000,  1.618034,  0.000000, -0.618034,  1.000000,  1.000000, -1.000000,
    1.000000,  1.000000,  1.000000,  1.000000,  1.000000, -1.000000,  0.618034,  1.618034,  0.000000,
    0.000000, -0.618034,  1.618034, -1.000000, -1.000000,  1.000000, -0.618034, -1.618034,  0.000000,
    0.000000, -0.618034,  1.618034, -0.618034, -1.618034,  0.000000,  0.618034, -1.618034,  0.000000,
    0.000000, -0.618034,  1.618034,  0.618034, -1.618034,  0.000000,  1.000000, -1.000000,  1.000000,
    -1.000000,  1.000000,  1.000000, -0.618034,  1.618034,  0.000000, -1.000000,  1.000000, -1.000000,
    -1.000000,  1.000000,  1.000000, -1.000000,  1.000000, -1.000000, -1.618034,  0.000000, -0.618034,
    -1.000000,  1.000000,  1.000000, -1.618034,  0.000000, -0.618034, -1.618034,  0.000000,  0.618034,
    -1.000000, -1.000000,  1.000000, -1.618034,  0.000000,  0.618034, -1.618034,  0.000000, -0.618034,
    -1.000000, -1.000000,  1.000000, -1.618034,  0.000000, -0.618034, -1.000000, -1.000000, -1.000000,
    -1.000000, -1.000000,  1.000000, -1.000000, -1.000000, -1.000000, -0.618034, -1.618034,  0.000000,
    1.618034,  0.000000,  0.618034,  1.000000, -1.000000,  1.000000,  0.618034, -1.618034,  0.000000,
    1.618034,  0.000000,  0.618034,  0.618034, -1.618034,  0.000000,  1.000000, -1.000000, -1.000000,
    1.618034,  0.000000,  0.618034,  1.000000, -1.000000, -1.000000,  1.618034,  0.000000, -0.618034,
    -0.618034,  1.618034,  0.000000,  0.618034,  1.618034,  0.000000,  1.000000,  1.000000, -1.000000,
    -0.618034,  1.618034,  0.000000,  1.000000,  1.000000, -1.000000,  0.000000,  0.618034, -1.618034,
    -0.618034,  1.618034,  0.000000,  0.000000,  0.618034, -1.618034, -1.000000,  1.000000, -1.000000,
    0.000000,  0.618034, -1.618034,  1.000000,  1.000000, -1.000000,  1.618034,  0.000000, -0.618034,
    0.000000,  0.618034, -1.618034,  1.618034,  0.000000, -0.618034,  1.000000, -1.000000, -1.000000,
    0.000000,  0.618034, -1.618034,  1.000000, -1.000000, -1.000000,  0.000000, -0.618034, -1.618034,
    -1.618034,  0.000000, -0.618034, -1.000000,  1.000000, -1.000000,  0.000000,  0.618034, -1.618034,
    -1.618034,  0.000000, -0.618034,  0.000000,  0.618034, -1.618034,  0.000000, -0.618034, -1.618034,
    -1.618034,  0.000000, -0.618034,  0.000000, -0.618034, -1.618034, -1.000000, -1.000000, -1.000000,
    0.000000, -0.618034, -1.618034,  1.000000, -1.000000, -1.000000,  0.618034, -1.618034,  0.000000,
    0.000000, -0.618034, -1.618034,  0.618034, -1.618034,  0.000000, -0.618034, -1.618034,  0.000000,
    0.000000, -0.618034, -1.618034, -0.618034, -1.618034,  0.000000, -1.000000, -1.000000, -1.000000};
  static const GLfloat doden[324]={
    0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,
    0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,
    0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,
    -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651,
    -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651,
    -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651,
    0.000000,  0.850651,  0.525731,  0.000000,  0.850651,  0.525731,  0.000000,  0.850651,  0.525731,
    0.000000,  0.850651,  0.525731,  0.000000,  0.850651,  0.525731,  0.000000,  0.850651,  0.525731,
    -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,  0.525731,
    0.850651,  0.525731,  0.000000,  0.850651,  0.525731,  0.000000,  0.850651,  0.525731,  0.000000,
    0.850651,  0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,  0.525731, -0.000000,
    0.850651,  0.525731, -0.000000,  0.850651,  0.525731, -0.000000,  0.850651,  0.525731, -0.000000,
    -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731,
    -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731,
    -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731,
    -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000,
    -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000,
    -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000,
    -0.850651, -0.525731, -0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731, -0.000000,
    -0.850651, -0.525731, -0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731, -0.000000,
    -0.850651, -0.525731, -0.000000, -0.850651, -0.525731,  0.000000, -0.850651, -0.525731,  0.000000,
    0.850651, -0.525731, -0.000000,  0.850651, -0.525731,  0.000000,  0.850651, -0.525731,  0.000000,
    0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,
    0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,
    -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731,
    0.000000,  0.850651, -0.525731,  0.000000,  0.850651, -0.525731,  0.000000,  0.850651, -0.525731,
    -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731, -0.000000,  0.850651, -0.525731,
    0.525731,  0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731,  0.000000, -0.850651,
    0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,
    0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,  0.525731, -0.000000, -0.850651,
    -0.525731,  0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731,  0.000000, -0.850651,
    -0.525731, -0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731, -0.000000, -0.850651,
    -0.525731, -0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731, -0.000000, -0.850651,
    0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731,  0.000000, -0.850651, -0.525731,
    -0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731,
    -0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731, -0.000000, -0.850651, -0.525731};
  glPushMatrix();
  glScaled(r,r,r);
  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, dodev);
  glEnableClientState(GL_NORMAL_ARRAY);
  glNormalPointer(GL_FLOAT, 0, doden);
  glDrawArrays(GL_TRIANGLES, 0, 108);
  glDisableClientState(GL_VERTEX_ARRAY);
  glDisableClientState(GL_NORMAL_ARRAY);
  glPopMatrix();
}
void molekul::icosaeder(GLfloat r){
  static const GLfloat icov[180]={
    1.000000,  0.000000,  1.618034,  0.000000,  1.618034,  1.000000, -1.000000,  0.000000,  1.618034,
    0.000000, -1.618034,  1.000000,  1.000000,  0.000000,  1.618034, -1.000000,  0.000000,  1.618034,
    1.000000,  0.000000,  1.618034,  1.618034,  1.000000,  0.000000,  0.000000,  1.618034,  1.000000,
    1.000000,  0.000000,  1.618034,  0.000000, -1.618034,  1.000000,  1.618034, -1.000000,  0.000000,
    1.000000,  0.000000,  1.618034,  1.618034, -1.000000,  0.000000,  1.618034,  1.000000,  0.000000,
    -1.000000,  0.000000,  1.618034,  0.000000,  1.618034,  1.000000, -1.618034,  1.000000,  0.000000,
    -1.000000,  0.000000,  1.618034, -1.618034, -1.000000,  0.000000,  0.000000, -1.618034,  1.000000,
    -1.000000,  0.000000,  1.618034, -1.618034,  1.000000,  0.000000, -1.618034, -1.000000,  0.000000,
    0.000000,  1.618034,  1.000000,  1.618034,  1.000000,  0.000000,  0.000000,  1.618034, -1.000000,
    0.000000,  1.618034,  1.000000,  0.000000,  1.618034, -1.000000, -1.618034,  1.000000,  0.000000,
    0.000000, -1.618034,  1.000000, -1.618034, -1.000000,  0.000000,  0.000000, -1.618034, -1.000000,
    0.000000, -1.618034,  1.000000,  0.000000, -1.618034, -1.000000,  1.618034, -1.000000,  0.000000,
    1.618034,  1.000000,  0.000000,  1.618034, -1.000000,  0.000000,  1.000000,  0.000000, -1.618034,
    1.618034,  1.000000,  0.000000,  1.000000,  0.000000, -1.618034,  0.000000,  1.618034, -1.000000,
    -1.618034,  1.000000,  0.000000, -1.000000,  0.000000, -1.618034, -1.618034, -1.000000,  0.000000,
    -1.618034,  1.000000,  0.000000,  0.000000,  1.618034, -1.000000, -1.000000,  0.000000, -1.618034,
    -1.618034, -1.000000,  0.000000, -1.000000,  0.000000, -1.618034,  0.000000, -1.618034, -1.000000,
    1.618034, -1.000000,  0.000000,  0.000000, -1.618034, -1.000000,  1.000000,  0.000000, -1.618034,
    0.000000,  1.618034, -1.000000,  1.000000,  0.000000, -1.618034, -1.000000,  0.000000, -1.618034,
    0.000000, -1.618034, -1.000000, -1.000000,  0.000000, -1.618034,  1.000000,  0.000000, -1.618034};
  static const GLfloat icon[180]={
    -0.000000,  0.356822,  0.934172, -0.000000,  0.356822,  0.934172, -0.000000,  0.356822,  0.934172,
    0.000000, -0.356822,  0.934172, -0.000000, -0.356822,  0.934172, -0.000000, -0.356822,  0.934172,
    0.577350,  0.577350,  0.577350,  0.577350,  0.577350,  0.577350,  0.577350,  0.577350,  0.577350,
    0.577350, -0.577350,  0.577350,  0.577350, -0.577350,  0.577350,  0.577350, -0.577350,  0.577350,
    0.934172, -0.000000,  0.356822,  0.934172, -0.000000,  0.356822,  0.934172, -0.000000,  0.356822,
    -0.577350,  0.577350,  0.577350, -0.577350,  0.577350,  0.577350, -0.577350,  0.577350,  0.577350,
    -0.577350, -0.577350,  0.577350, -0.577350, -0.577350,  0.577350, -0.577350, -0.577350,  0.577350,
    -0.934172, -0.000000,  0.356822, -0.934172, -0.000000,  0.356822, -0.934172, -0.000000,  0.356822,
    0.356822,  0.934172, -0.000000,  0.356822,  0.934172, -0.000000,  0.356822,  0.934172, -0.000000,
    -0.356822,  0.934172, -0.000000, -0.356822,  0.934172, -0.000000, -0.356822,  0.934172, -0.000000,
    -0.356822, -0.934172, -0.000000, -0.356822, -0.934172, -0.000000, -0.356822, -0.934172, -0.000000,
    0.356822, -0.934172, -0.000000,  0.356822, -0.934172, -0.000000,  0.356822, -0.934172, -0.000000,
    0.934172, -0.000000, -0.356822,  0.934172, -0.000000, -0.356822,  0.934172, -0.000000, -0.356822,
    0.577350,  0.577350, -0.577350,  0.577350,  0.577350, -0.577350,  0.577350,  0.577350, -0.577350,
    -0.934172, -0.000000, -0.356822, -0.934172, -0.000000, -0.356822, -0.934172, -0.000000, -0.356822,
    -0.577350,  0.577350, -0.577350, -0.577350,  0.577350, -0.577350, -0.577350,  0.577350, -0.577350,
    -0.577350, -0.577350, -0.577350, -0.577350, -0.577350, -0.577350, -0.577350, -0.577350, -0.577350,
    0.577350, -0.577350, -0.577350,  0.577350, -0.577350, -0.577350,  0.577350, -0.577350, -0.577350,
    -0.000000,  0.356822, -0.934172, -0.000000,  0.356822, -0.934172, -0.000000,  0.356822, -0.934172,
    0.000000, -0.356822, -0.934172,  0.000000, -0.356822, -0.934172,  0.000000, -0.356822, -0.934172};
  glPushMatrix();
  glScaled(r,r,r);
  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, icov);
  glEnableClientState(GL_NORMAL_ARRAY);
  glNormalPointer(GL_FLOAT, 0, icon);
  glDrawArrays(GL_TRIANGLES, 0, 60);
  glDisableClientState(GL_VERTEX_ARRAY);
  glDisableClientState(GL_NORMAL_ARRAY);
  glPopMatrix();

}
void molekul::triacontaeder(GLfloat r){
  static const GLfloat triv[540]={ 
    1.000000,  0.000000,  1.618034,  0.000000,  0.618034,  1.618034,  0.000000, -0.618034,  1.618034,
    1.000000,  0.000000,  1.618034,  1.000000,  1.000000,  1.000000,  0.000000,  0.618034,  1.618034,
    1.000000,  0.000000,  1.618034,  0.000000, -0.618034,  1.618034,  1.000000, -1.000000,  1.000000,
    1.000000,  0.000000,  1.618034,  1.618034,  0.000000,  0.618034,  1.000000,  1.000000,  1.000000,
    1.000000,  0.000000,  1.618034,  1.000000, -1.000000,  1.000000,  1.618034,  0.000000,  0.618034,
    1.618034,  0.000000,  0.618034,  1.618034,  0.000000, -0.618034,  1.618034,  1.000000,  0.000000,
    1.618034,  0.000000,  0.618034,  1.618034, -1.000000,  0.000000,  1.618034,  0.000000, -0.618034,
    -1.618034,  0.000000,  0.618034, -1.618034,  1.000000,  0.000000, -1.618034,  0.000000, -0.618034,
    -1.618034,  0.000000,  0.618034, -1.618034,  0.000000, -0.618034, -1.618034, -1.000000,  0.000000,
    1.618034,  1.000000,  0.000000,  1.000000,  1.000000, -1.000000,  0.618034,  1.618034,  0.000000,
    1.618034,  1.000000,  0.000000,  1.618034,  0.000000, -0.618034,  1.000000,  1.000000, -1.000000,
    0.000000,  0.618034,  1.618034, -1.000000,  0.000000,  1.618034,  0.000000, -0.618034,  1.618034,
    0.000000,  0.618034,  1.618034, -1.000000,  1.000000,  1.000000, -1.000000,  0.000000,  1.618034,
    -0.618034,  1.618034,  0.000000, -1.000000,  1.000000, -1.000000, -1.618034,  1.000000,  0.000000,
    -0.618034,  1.618034,  0.000000,  0.000000,  1.618034, -1.000000, -1.000000,  1.000000, -1.000000,
    -1.618034,  1.000000,  0.000000, -1.000000,  1.000000, -1.000000, -1.618034,  0.000000, -0.618034,
    0.000000,  0.618034,  1.618034,  0.000000,  1.618034,  1.000000, -1.000000,  1.000000,  1.000000,
    -1.618034, -1.000000,  0.000000, -1.000000, -1.000000, -1.000000, -0.618034, -1.618034,  0.000000,
    -1.618034, -1.000000,  0.000000, -1.618034,  0.000000, -0.618034, -1.000000, -1.000000, -1.000000,
    0.618034, -1.618034,  0.000000,  1.000000, -1.000000, -1.000000,  1.618034, -1.000000,  0.000000,
    0.618034, -1.618034,  0.000000,  0.000000, -1.618034, -1.000000,  1.000000, -1.000000, -1.000000,
    1.618034, -1.000000,  0.000000,  1.000000, -1.000000, -1.000000,  1.618034,  0.000000, -0.618034,
    1.000000,  1.000000, -1.000000,  0.000000,  0.618034, -1.618034,  0.000000,  1.618034, -1.000000,
    1.000000,  1.000000, -1.000000,  1.000000,  0.000000, -1.618034,  0.000000,  0.618034, -1.618034,
    0.000000,  1.618034, -1.000000,  0.000000,  0.618034, -1.618034, -1.000000,  1.000000, -1.000000,
    -1.000000,  0.000000,  1.618034, -1.000000, -1.000000,  1.000000,  0.000000, -0.618034,  1.618034,
    -1.000000, -1.000000, -1.000000,  0.000000, -0.618034, -1.618034,  0.000000, -1.618034, -1.000000,
    -1.000000, -1.000000, -1.000000, -1.000000,  0.000000, -1.618034,  0.000000, -0.618034, -1.618034,
    -1.000000,  0.000000,  1.618034, -1.000000,  1.000000,  1.000000, -1.618034,  0.000000,  0.618034,
    0.000000, -1.618034, -1.000000,  0.000000, -0.618034, -1.618034,  1.000000, -1.000000, -1.000000,
    -1.000000,  0.000000,  1.618034, -1.618034,  0.000000,  0.618034, -1.000000, -1.000000,  1.000000,
    1.000000, -1.000000, -1.000000,  0.000000, -0.618034, -1.618034,  1.000000,  0.000000, -1.618034,
    1.000000,  0.000000, -1.618034,  0.000000, -0.618034, -1.618034,  0.000000,  0.618034, -1.618034,
    0.000000,  0.618034, -1.618034,  0.000000, -0.618034, -1.618034, -1.000000,  0.000000, -1.618034,
    0.000000, -0.618034,  1.618034,  0.000000, -1.618034,  1.000000,  1.000000, -1.000000,  1.000000,
    1.000000,  1.000000,  1.000000,  1.618034,  1.000000,  0.000000,  0.618034,  1.618034,  0.000000,
    1.000000,  1.000000,  1.000000,  0.618034,  1.618034,  0.000000,  0.000000,  1.618034,  1.000000,
    0.000000,  1.618034,  1.000000,  0.618034,  1.618034,  0.000000, -0.618034,  1.618034,  0.000000,
    0.000000,  1.618034,  1.000000, -0.618034,  1.618034,  0.000000, -1.000000,  1.000000,  1.000000,
    -1.000000, -1.000000,  1.000000, -1.618034, -1.000000,  0.000000, -0.618034, -1.618034,  0.000000,
    -1.000000, -1.000000,  1.000000, -0.618034, -1.618034,  0.000000,  0.000000, -1.618034,  1.000000,
    0.000000, -1.618034,  1.000000, -0.618034, -1.618034,  0.000000,  0.618034, -1.618034,  0.000000,
    0.000000, -1.618034,  1.000000,  0.618034, -1.618034,  0.000000,  1.000000, -1.000000,  1.000000,
    0.618034,  1.618034,  0.000000,  0.000000,  1.618034, -1.000000, -0.618034,  1.618034,  0.000000,
    -0.618034, -1.618034,  0.000000,  0.000000, -1.618034, -1.000000,  0.618034, -1.618034,  0.000000,
    0.618034,  1.618034,  0.000000,  1.000000,  1.000000, -1.000000,  0.000000,  1.618034, -1.000000,
    0.000000,  0.618034,  1.618034,  1.000000,  1.000000,  1.000000,  0.000000,  1.618034,  1.000000,
    -0.618034, -1.618034,  0.000000, -1.000000, -1.000000, -1.000000,  0.000000, -1.618034, -1.000000,
    1.618034,  0.000000, -0.618034,  1.000000,  0.000000, -1.618034,  1.000000,  1.000000, -1.000000,
    1.618034,  0.000000, -0.618034,  1.000000, -1.000000, -1.000000,  1.000000,  0.000000, -1.618034,
    -1.618034,  0.000000, -0.618034, -1.000000,  1.000000, -1.000000, -1.000000,  0.000000, -1.618034,
    -1.618034,  0.000000, -0.618034, -1.000000,  0.000000, -1.618034, -1.000000, -1.000000, -1.000000,
    -1.000000,  1.000000, -1.000000,  0.000000,  0.618034, -1.618034, -1.000000,  0.000000, -1.618034,
    0.000000, -0.618034,  1.618034, -1.000000, -1.000000,  1.000000,  0.000000, -1.618034,  1.000000,
    1.000000,  1.000000,  1.000000,  1.618034,  0.000000,  0.618034,  1.618034,  1.000000,  0.000000,
    -1.000000,  1.000000,  1.000000, -1.618034,  1.000000,  0.000000, -1.618034,  0.000000,  0.618034,
    -1.000000,  1.000000,  1.000000, -0.618034,  1.618034,  0.000000, -1.618034,  1.000000,  0.000000,
    -1.000000, -1.000000,  1.000000, -1.618034,  0.000000,  0.618034, -1.618034, -1.000000,  0.000000,
    1.000000, -1.000000,  1.000000,  1.618034, -1.000000,  0.000000,  1.618034,  0.000000,  0.618034,
    1.000000, -1.000000,  1.000000,  0.618034, -1.618034,  0.000000,  1.618034, -1.000000,  0.000000};
  static const GLfloat trin[540]={ 
    -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,  1.000000,
    0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,
    0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,
    0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,
    0.809017, -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,
    1.000000, -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,
    1.000000, -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,
    -1.000000, -0.000000, -0.000000, -1.000000, -0.000000, -0.000000, -1.000000, -0.000000, -0.000000,
    -1.000000, -0.000000,  0.000000, -1.000000, -0.000000,  0.000000, -1.000000, -0.000000,  0.000000,
    0.500000,  0.809017, -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,  0.809017, -0.309017,
    0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,
    -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,  1.000000,
    -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,  0.809017,
    -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017,
    -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017,
    -0.809017,  0.309017, -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,  0.309017, -0.500000,
    -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,  0.809017,
    -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017,
    -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000,
    0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,
    0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,
    0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,
    0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,
    0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,
    -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017,
    -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017,
    -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017,
    -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017,
    -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000,
    0.309017, -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,
    -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000,
    0.309017, -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,
    -0.000000, -0.000000, -1.000000, -0.000000, -0.000000, -1.000000, -0.000000, -0.000000, -1.000000,
    -0.000000,  0.000000, -1.000000, -0.000000,  0.000000, -1.000000, -0.000000,  0.000000, -1.000000,
    0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,
    0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,
    0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,
    -0.000000,  1.000000, -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,  1.000000, -0.000000,
    -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017,
    -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,  0.309017,
    -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,  0.309017,
    -0.000000, -1.000000, -0.000000, -0.000000, -1.000000, -0.000000, -0.000000, -1.000000, -0.000000,
    0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,
    -0.000000,  1.000000, -0.000000, -0.000000,  1.000000, -0.000000, -0.000000,  1.000000, -0.000000,
    -0.000000, -1.000000,  0.000000, -0.000000, -1.000000,  0.000000, -0.000000, -1.000000,  0.000000,
    0.500000,  0.809017, -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,  0.809017, -0.309017,
    0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,
    -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017,
    0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,
    0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,
    -0.809017,  0.309017, -0.500000, -0.809017,  0.309017, -0.500000, -0.809017,  0.309017, -0.500000,
    -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000,
    -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017,
    -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017,
    0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,
    -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000,
    -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017,
    -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000,
    0.809017, -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,  0.809017, -0.309017,  0.500000,
    0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017};
  glPushMatrix();
  glScaled(r,r,r);
  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, triv);
  glEnableClientState(GL_NORMAL_ARRAY);
  glNormalPointer(GL_FLOAT, 0, trin);
  glDrawArrays(GL_TRIANGLES, 0, 180);
  glDisableClientState(GL_VERTEX_ARRAY);
  glDisableClientState(GL_NORMAL_ARRAY);
  glPopMatrix();


}
void molekul::cube(GLfloat r){
  static const GLfloat cubv[108]={
    -0.618034, -1.618034,  0.000000, -1.618034,  0.000000, -0.618034,  0.000000,  0.618034, -1.618034,
    -0.618034, -1.618034,  0.000000,  0.000000,  0.618034, -1.618034,  1.000000, -1.000000, -1.000000,
    -1.000000,  1.000000,  1.000000,  0.618034,  1.618034,  0.000000,  0.000000,  0.618034, -1.618034,
    -1.000000,  1.000000,  1.000000,  0.000000,  0.618034, -1.618034, -1.618034,  0.000000, -0.618034,
    -1.000000,  1.000000,  1.000000, -0.618034, -1.618034,  0.000000,  0.000000, -0.618034,  1.618034,
    -1.000000,  1.000000,  1.000000, -1.618034,  0.000000, -0.618034, -0.618034, -1.618034,  0.000000,
    -1.000000,  1.000000,  1.000000,  1.618034,  0.000000,  0.618034,  0.618034,  1.618034,  0.000000,
    -1.000000,  1.000000,  1.000000,  0.000000, -0.618034,  1.618034,  1.618034,  0.000000,  0.618034,
    0.000000, -0.618034,  1.618034,  1.000000, -1.000000, -1.000000,  1.618034,  0.000000,  0.618034,
    0.000000, -0.618034,  1.618034, -0.618034, -1.618034,  0.000000,  1.000000, -1.000000, -1.000000,
    1.618034,  0.000000,  0.618034,  0.000000,  0.618034, -1.618034,  0.618034,  1.618034,  0.000000,
    1.618034,  0.000000,  0.618034,  1.000000, -1.000000, -1.000000,  0.000000,  0.618034, -1.618034};
  static const GLfloat cubn[108]={
    -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017,
    -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017, -0.309017, -0.500000, -0.809017,
    -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017,
    -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017, -0.500000,  0.809017, -0.309017,
    -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000,
    -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000, -0.809017, -0.309017,  0.500000,
    0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,
    0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,  0.309017,  0.500000,  0.809017,
    0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,
    0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,  0.500000, -0.809017,  0.309017,
    0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,
    0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000,  0.809017,  0.309017, -0.500000};
  glPushMatrix();
  glScaled(r,r,r);
  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, cubv);
  glEnableClientState(GL_NORMAL_ARRAY);
  glNormalPointer(GL_FLOAT, 0, cubn);
  glDrawArrays(GL_TRIANGLES, 0, 36);
  glDisableClientState(GL_VERTEX_ARRAY);
  glDisableClientState(GL_NORMAL_ARRAY);
  glPopMatrix();
}
double molekul::dieder(V3 a,V3 b, V3 c){

  static double erg;  
  double A[3],B[3],sig;
  sig=a.x*b.y*c.z - a.z*b.y*c.x +
    a.z*b.x*c.y - a.x*b.z*c.y +
    a.y*b.z*c.x - a.y*b.x*c.z;
  
  A[0]= a.y*b.z - a.z*b.y;
  A[1]=-a.x*b.z + a.z*b.x;
  A[2]= a.x*b.y - a.y*b.x;

  B[0]=-b.y*c.z + b.z*c.y;
  B[1]= b.x*c.z - b.z*c.x;
  B[2]=-b.x*c.y + b.y*c.x;

  erg=(A[0]*B[0]+A[1]*B[1]+A[2]*B[2])/(sqrt(A[0]*A[0]+A[1]*A[1]+A[2]*A[2])*sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]));
  erg=acos(erg)/M_PI*180.0f;
 return (sig>0)?(erg):(-erg);
}
double molekul::winkel(V3 a,V3 b){

  static double erg;
  erg=(a.x*b.x+a.y*b.y+a.z*b.z)/(sqrt(a.x*a.x+a.y*a.y+a.z*a.z)*sqrt(b.x*b.x+b.y*b.y+b.z*b.z));
  erg=acos(erg)/M_PI*180.0;
 return(erg);
}
V3 molekul::kreuzX(double x1,double y1,double z1,double x2,double y2,double z2) {

  static V3 erg;
  erg.x=-y1*z2+z1*y2;
  erg.y=-z1*x2+x1*z2;
  erg.z=-x1*y2+y1*x2;
 return(erg);
}
void molekul::initDir(){
  fvl=1;
  firstHL=0;
  lastHL=0;
  bonds_made=0;
  knopf_made=0;
  adp=1;
  intern=0;
  proba=50;
  lod=3;

}//Init Dir
int molekul::Get_OZ(const QString S1){
QString s=S1.section(QRegExp("[^A-Za-z]"),0,0);
//qDebug()<<s<<S1;
if (s=="Cv") return 5;
static QStringList PSE;
PSE<<"H"<<"HE"<<"LI"<<"BE"<<"B"<<"C"<<"N"<<"O"<<"F"<<"NE"<<"NA"<<"MG"<<"AL"<<"SI"<<"P"<<"S"<<"CL"<<"AR"<<
			     "K"<<"CA"<<"SC"<<"TI"<<"V"<<"CR"<<"MN"<<"FE"<<"CO"<<"NI"<<"CU"<<"ZN"<<"GA"<<"GE"<<"AS"<<"SE"<<"BR"<<"KR"<<
                 "RB"<<"SR"<<"Y"<<"ZR"<<"NB"<<"MO"<<"TC"<<"RU"<<"RH"<<"PD"<<"AG"<<"CD"<<"IN"<<"SN"<<"SB"<<"TE"<<"I"<<"XE"<<
			     "CS"<<"BA"<< "LA"<<"CE"<<"PR"<<"ND"<<"PM"<<"SM"<<"EU"<<"GD"<<"TB"<<"DY"<<"HO"<<"ER"<<"TM"<<"YB"<<"LU"<<
			     "HF"<<"TA"<<"W"<<"RE"<<"OS"<<"IR"<<"PT"<<"AU"<<"HG"<<"TL"<<"PB"<<"BI"<<"PO"<<"AT"<<"RN"<<"FR"<<"RA"<<
			     "AC"<<"TH"<<"PA"<<"U"<<"NP"<<"PU"<<"AM"<<"CM"<<"BK"<<"CF"<<"ES"<<"FM"<<"MD"<<"NO"<<"LR"<<"KU"<<"HA"<<"RF"<<"NS"<<"HS"<<"MT";
return PSE.indexOf(QRegExp(s.toUpper()));
}
int molekul::Get_OZ(const char * S1){//109 Elemente solltenReichen zumindest fuer XD ;-)
  char s1[3]="\0\0";
  strncpy(s1,S1,3);
  if (strlen(S1)>1) s1[1]=tolower(S1[1]);
  char PSE_Symbol[109][3] = {"H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar",
			     "K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr",
                 "Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe",
			     "Cs","Ba", "La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu",
			     "Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra",
			     "Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Ku","Ha","Rf","Ns","Hs","Mt"};

  for (int i=0;i<109;i++) if (!strcmp(PSE_Symbol[i],s1))return i;//Je hoeher die Ordnungzahl desto laenger dauerts Halt!! Dumm aber einfach.
 return -1;
}
#define ROTATE(a,i,j,k,l) g=a[i][j];h=a[k][l];a[i][j]=g-s*(h+g*tau); a[k][l]=h+s*(g-h*tau);
//NumericalRecepies....
double * molekul::jacobi(double a[3][3], double d[3]) { 

  int j,iq,ip,i,n=3,nrot; 
  double tresh,theta,tau,t,sm,s,h,g,c; 
  double b[3],z[3],v[3][3];
  static double erg[4]={0.0,1.0,0.0,0.0};
  for (ip=1;ip<=n;ip++) {   
    for (iq=1;iq<=n;iq++) v[ip-1][iq-1]=0.0; 
    v[ip-1][ip-1]=1.0; 
  } 
  for (ip=1;ip<=n;ip++) {  
    b[ip-1]=d[ip-1]=a[ip-1][ip-1]; 
    z[ip-1]=0.0; 
  } 
  nrot=0; 
  for (i=1;i<=150;i++) {
    sm=0.0; 
    for (ip=1;ip<=n-1;ip++) { 
      for (iq=ip+1;iq<=n;iq++) 
	sm += fabs(a[ip-1][iq-1]);       
    } 



    if (float(sm) == 0.0) { 
      if ((v[0][0]+v[1][1]+v[2][2])!=3.0) {
      erg[0]=acos((v[0][0]+v[1][1]+v[2][2]-1.0)/2.0);
      erg[1]=(v[2][1]-v[1][2])/(2.0*sin(erg[0]));
      erg[2]=(v[0][2]-v[2][0])/(2.0*sin(erg[0]));
      erg[3]=(v[1][0]-v[0][1])/(2.0*sin(erg[0]));
      erg[0]*=180.0/M_PI;}
      else {erg[0]=0.0;erg[1]=1.0;erg[2]=0.0;erg[3]=0.0; }

/*  printf("=a======================================\n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f\n========================================\n",
		  d[0],d[1],d[2],v[0][0],v[0][1],v[0][2]
		  ,v[1][0],v[1][1],v[1][2]
		  ,v[2][0],v[2][1],v[2][2]

		  );*/
     return (double*) erg;
    }
    if (i < 4) tresh=0.0001;  
    else tresh=0.000001;  
    for (ip=1;ip<=n-1;ip++) { 
      for (iq=ip+1;iq<=n;iq++) { 

	g=100.0*fabs(a[ip-1][iq-1]);  
	if ((i > 4) && ((fabs(d[ip-1])+g) == fabs(d[ip-1])) && ((fabs(d[iq-1])+g) == fabs(d[iq-1]))) {a[ip-1][iq-1]=0.0;}
	else if (fabs(a[ip-1][iq-1]) >= tresh) { 
	  h=d[iq-1]-d[ip-1]; 
	  if ((fabs(h)+g) == fabs(h)) {t=(a[ip-1][iq-1])/h; } 
	  else { theta=0.5*h/(a[ip-1][iq-1]);  
	  t=1.0/(fabs(theta)+sqrt(1.0+theta*theta)); 
	  if (theta < 0.0) {t = -1.0*t;}
	  } 
	  c=1.0/sqrt(1+t*t); 
	  s=t*c; 
	  tau=s/(1.0+c); 
	  h=t*a[ip-1][iq-1];
	  z[ip-1] -= h;
	  z[iq-1] += h;
	  d[ip-1] -= h;
	  d[iq-1] += h;
	  a[ip-1][iq-1]=0.0;
	  for (j=1;j<=ip-1;j++) { 
           ROTATE(a,j-1,ip-1,j-1,iq-1)

	      } 
	  for (j=ip+1;j<=iq-1;j++) { 
           ROTATE(a,ip-1,j-1,j-1,iq-1)

	      } 
	  for (j=iq+1;j<=n;j++) {  
           ROTATE(a,ip-1,j-1,iq-1,j-1)

	      } 
	  for (j=1;j<=n;j++) { 
           ROTATE(v,j-1,ip-1,j-1,iq-1)
	      } 
	  ++(nrot);	  

	}
      } 
    } 
    for (ip=1;ip<=n;ip++) { 
      b[ip-1] += z[ip-1];
      d[ip-1] =b[ip-1];
      z[ip-1] =0.0;
    } 
  } 
  erg[0]=acos((v[0][0]+v[1][1]+v[2][2]-1.0)/2.0);
  if (erg[0]==0) {
    erg[1]=1.0;
    erg[2]=0.0;
    erg[3]=0.0;
  }else{
  erg[1]=(v[2][1]-v[1][2])/(2.0*sin(erg[0]));
  erg[2]=(v[0][2]-v[2][0])/(2.0*sin(erg[0]));
  erg[3]=(v[1][0]-v[0][1])/(2.0*sin(erg[0]));
  erg[0]*=180.0/M_PI;
  }
/*  printf("========================================\n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f\n========================================\n",
		  d[0],d[1],d[2],v[0][0],v[0][1],v[0][2]
		  ,v[1][0],v[1][1],v[1][2]
		  ,v[2][0],v[2][1],v[2][2]

		  );*/




 return (double*)erg;
}

Matrix molekul::jacobi(Matrix A, V3 &D) {
    double a[3][3]={{A.m11,A.m12,A.m13},
                    {A.m21,A.m22,A.m23},
                    {A.m31,A.m32,A.m33}};
    double d[3]={D.x,D.y,D.z};
  int j,iq,ip,i,n=3,nrot;
  double tresh=0,theta,tau,t,sm,s,h,g,c;
  double b[3],z[3],v[3][3];
  for (ip=1;ip<=n;ip++) {
    for (iq=1;iq<=n;iq++) v[ip-1][iq-1]=0.0;
    v[ip-1][ip-1]=1.0;
  }
  for (ip=1;ip<=n;ip++) {
    b[ip-1]=d[ip-1]=a[ip-1][ip-1];
    z[ip-1]=0.0;
  }
  nrot=0;
  for (i=1;i<=150;i++) {
    sm=0.0;
    for (ip=1;ip<=n-1;ip++) {
      for (iq=ip+1;iq<=n;iq++)
        sm += fabs(a[ip-1][iq-1]);
    }



    if (float(sm) <tresh) {
        D=V3(d[0],d[1],d[2]);
      return Matrix(v[0][0],v[0][1],v[0][2],
                    v[1][0],v[1][1],v[1][2],
                    v[2][0],v[2][1],v[2][2]);
    }
    if (i < 4) tresh=0.0001;
    else tresh=0.000001;
    for (ip=1;ip<=n-1;ip++) {
      for (iq=ip+1;iq<=n;iq++) {

        g=100.0*fabs(a[ip-1][iq-1]);
        if ((i > 4) && ((fabs(d[ip-1])+g) == fabs(d[ip-1])) && ((fabs(d[iq-1])+g) == fabs(d[iq-1]))) {a[ip-1][iq-1]=0.0;}
        else if (fabs(a[ip-1][iq-1]) >= tresh) {
          h=d[iq-1]-d[ip-1];
          if ((fabs(h)+g) == fabs(h)) {t=(a[ip-1][iq-1])/h; }
          else { theta=0.5*h/(a[ip-1][iq-1]);
          t=1.0/(fabs(theta)+sqrt(1.0+theta*theta));
          if (theta < 0.0) {t = -1.0*t;}
          }
          c=1.0/sqrt(1+t*t);
          s=t*c;
          tau=s/(1.0+c);
          h=t*a[ip-1][iq-1];
          z[ip-1] -= h;
          z[iq-1] += h;
          d[ip-1] -= h;
          d[iq-1] += h;
          a[ip-1][iq-1]=0.0;
          for (j=1;j<=ip-1;j++) {
           ROTATE(a,j-1,ip-1,j-1,iq-1)

              }
          for (j=ip+1;j<=iq-1;j++) {
           ROTATE(a,ip-1,j-1,j-1,iq-1)

              }
          for (j=iq+1;j<=n;j++) {
           ROTATE(a,ip-1,j-1,iq-1,j-1)

              }
          for (j=1;j<=n;j++) {
           ROTATE(v,j-1,ip-1,j-1,iq-1)
              }
          ++(nrot);

        }
      }
    }
    for (ip=1;ip<=n;ip++) {
      b[ip-1] += z[ip-1];
      d[ip-1] =b[ip-1];
      z[ip-1] =0.0;
    }
  }

  D=V3(d[0],d[1],d[2]);
  return Matrix(v[0][0],v[0][1],v[0][2],
                v[1][0],v[1][1],v[1][2],
                v[2][0],v[2][1],v[2][2]);
}

void molekul::atoms(QList<INP> xdinp,const int proba){//ADP Schwingungsellipsoide
  GLfloat black[4]={0.0, 0.0, 0.0, 1.0};
  GLfloat white[4]={0.2, 0.2, 0.2, 0.0};
  glBindTexture(GL_TEXTURE_2D, hbtex2);
  glEnable(GL_TEXTURE_2D);
  double EV[3], *erg=NULL;
  double a[3][3];
  int mylod =lod;
  for (int j=0;j<xdinp.size();j++){//for atmax
    int  nonPositiveDefinite=0;
//    qDebug()<<__LINE__<<xdinp[j].OrdZahl;
      int myStyle=(xdinp[j].OrdZahl>-1)?aStyle[xdinp[j].OrdZahl]:0;
    int myAdp=(myStyle&ATOM_STYLE_NOADP)?0:adp;
    if (!dratom){
      glPushMatrix () ;
    glTranslated(xdinp[j].kart.x,xdinp[j].kart.y,xdinp[j].kart.z) ;
    //double rad=(atom.at(i).an==-2)?0.5:qPeakRad;
    double rad=(xdinp[j].OrdZahl>-1)?arad[xdinp[j].OrdZahl]:0.15;

      if (tubifiedAtoms) rad = bondStrength;

      if ((myAdp)&&(xdinp[j].OrdZahl>-1)) {//adp
	a[0][0]=xdinp[j].u.m11;
	a[0][1]=xdinp[j].u.m12;
	a[0][2]=xdinp[j].u.m13;
	a[1][0]=xdinp[j].u.m21;
	a[1][1]=xdinp[j].u.m22;
	a[1][2]=xdinp[j].u.m23;
	a[2][0]=xdinp[j].u.m31;
	a[2][1]=xdinp[j].u.m32;
	a[2][2]=xdinp[j].u.m33;

	erg=jacobi(a,EV);
        if ((EV[0]>0)&&(EV[1]>0)&&(EV[2]>0)){
          nonPositiveDefinite=0;

	EV[0]=(EV[0]>0.001)?EV[0]:0.001;
	EV[1]=(EV[1]>0.001)?EV[1]:0.001;
	EV[2]=(EV[2]>0.001)?EV[2]:0.001;
	glRotated(Ato4d(erg));
	switch (proba ) {
	case 10 :{ glScaled(0.76*sqrt(EV[0]),0.76*sqrt(EV[1]),0.76*sqrt(EV[2]));break;}   //Hauptachsen der Eliipsoide 10% Wahrscheinlichkeit
	case 30 :{ glScaled(1.19*sqrt(EV[0]),1.19*sqrt(EV[1]),1.19*sqrt(EV[2]));break;}   //Hauptachsen der Eliipsoide 30% Wahrscheinlichkeit
	case 50 :{ glScaled(1.54*sqrt(EV[0]),1.54*sqrt(EV[1]),1.54*sqrt(EV[2]));break;}   //Hauptachsen der Eliipsoide 50% Wahrscheinlichkeit
	case 70 :{ glScaled(1.91*sqrt(EV[0]),1.91*sqrt(EV[1]),1.91*sqrt(EV[2]));break;}   //Hauptachsen der Eliipsoide 70% Wahrscheinlichkeit
	case 90 :{ glScaled(2.50*sqrt(EV[0]),2.50*sqrt(EV[1]),2.50*sqrt(EV[2]));break;}   //Hauptachsen der Eliipsoide 90% Wahrscheinlichkeit
	default: ;
	}
        }else nonPositiveDefinite=1;
      }
      else if (xdinp[j].OrdZahl>-1){
	if (rad) glScaled(rad,rad,rad);
	else glScaled(0.15,0.15,0.15);
      }
      GLUquadricObj *q = gluNewQuadric();
      gluQuadricNormals(q, GL_SMOOTH);   

      if (xdinp[j].OrdZahl>-1) glColor4fv(Acol[xdinp[j].OrdZahl]); 
      if (xdinp[j].part) glMaterialfv( GL_FRONT_AND_BACK, GL_EMISSION, white );
      else glMaterialfv( GL_FRONT_AND_BACK, GL_EMISSION, black );


      if ((rad>0)&&(xdinp[j].OrdZahl>-1)) {
        if (nonPositiveDefinite) cube(rad); else{
        if (myAdp&&intern) ellipse(aStyle[xdinp[j].OrdZahl]);else
          if ((!myAdp)||((aStyle[xdinp[j].OrdZahl]&ATOM_STYLE_SPHERE)&&(!(aStyle[xdinp[j].OrdZahl]&ATOM_STYLE_SOLID)))){
            gluSphere(q,0.96,6*mylod,6*mylod);//Atom als Kugel zeichnen
            if (mylod!=3) gluSphere(q,0.96,6*mylod,6*mylod);  
            else sp(0.96);
          }
        if (xdinp[j].atomname[0]=='D') printf("%s %f \n",xdinp[j].atomname,rad);
        }
      }
      else {
        if (xdinp[j].atomname[0]=='C') {
          glColor3f(0.0,0.3,0.1);
          //    qDebug()<<__LINE__<<xdinp[j].peakHeight<<pmin,pmax;;
          switch (xdinp[j].cptype){
            case 6:glColor3f(0.0,0.7,0.1);break;
            case 4:glColor3f(0.9,0.8,0.1);break;
            case 2:glColor3f(0.9,0.1,0.1);break;
            case 0:break;
          }
          //ikosa(CPRad);
          dodecaeder(CPRad);
        }else{
          if (xdinp[j].atomname[0]=='D') {glColor3f(0.5,0.0,0.5);triacontaeder(qPeakRad);}else
          if (xdinp[j].atomname[0]=='H') {glColor3f(0.5,0.0,0.0);icosaeder(qPeakRad);}else
          if (xdinp[j].atomname[0]=='P') {glColor3f(0.0,0.0,0.6);icosaeder(qPeakRad);}else
          if (xdinp[j].atomname[0]=='O') {glColor3f(0.0,0.3,0.1);icosaeder(qPeakRad);}else
          if (xdinp[j].atomname[0]=='Q') {
            Farbverlauf(xdinp[j].peakHeight,pmin,pmax);
           // dodecaeder(qPeakRad);
            icosaeder(qPeakRad);
            }
          else {
            Farbverlauf(xdinp[j].amul,-1.5,1.5);
            triacontaeder(CPRad);
          }
        }
      }

      glPopMatrix(); 
  }else {
    glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
    glDisable(GL_DEPTH_TEST);
    glPushMatrix () ;
    glTranslated(xdinp[j].kart.x,xdinp[j].kart.y,xdinp[j].kart.z) ;
    glColor3d(1.0, 1.0,0.0);

    triacontaeder(0.3);
    /*
    GLUquadricObj *q = gluNewQuadric();
    gluQuadricNormals(q, GL_SMOOTH);   
    glDisable(GL_DEPTH_TEST);
    glColor3d(1.0, 1.0,0.0);
    gluQuadricDrawStyle(q,GLU_LINE);
    gluSphere(q,0.3,5,5);
    glEnable(GL_DEPTH_TEST);
    */
    glPopMatrix(); 
    glEnable(GL_DEPTH_TEST);
    glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
  }
  }
 glDisable(GL_TEXTURE_2D);
}

QString molekul::pse(int oz){
  static QStringList PSE;

  PSE<<"H"<<"He"<<"Li"<<"Be"<<"B"<<"C"<<"N"<<"O"<<"F"<<"Ne"<<"Na"<<"Mg"<<"Al"<<"Si"<<"P"<<"S"<<"Cl"<<"Ar"<<
	  "K"<<"Ca"<<"Sc"<<"Ti"<<"V"<<"Cr"<<"Mn"<<"Fe"<<"Co"<<"Ni"<<"Cu"<<"Zn"<<"Ga"<<"Ge"<<"As"<<"Se"<<"Br"<<"Kr"<<
          "Rb"<<"Sr"<<"Y"<<"Zr"<<"Nb"<<"Mo"<<"Tc"<<"Ru"<<"Rh"<<"Pd"<<"Ag"<<"Cd"<<"In"<<"Sn"<<"Sb"<<"Te"<<"I"<<"Xe"<<
	  "Cs"<<"Ba"<< "La"<<"Ce"<<"Pr"<<"Nd"<<"Pm"<<"Sm"<<"Eu"<<"Gd"<<"Tb"<<"Dy"<<"Ho"<<"Er"<<"Tm"<<"Yb"<<"Lu"<<
	  "Hf"<<"Ta"<<"W"<<"Re"<<"Os"<<"Ir"<<"Pt"<<"Au"<<"Hg"<<"Tl"<<"Pb"<<"Bi"<<"Po"<<"At"<<"Rn"<<"Fr"<<"Ra"<<
	  "Ac"<<"Th"<<"Pa"<<"U"<<"Np"<<"Pu"<<"Am"<<"Cm"<<"Bk"<<"Cf"<<"Es"<<"Fm"<<"Md"<<"No"<<"Lr"<<"Ku"<<"Ha"<<"Rf"<<"Ns"<<"Hs"<<"Mt";
  if ((oz>-1)&&(oz<PSE.size())) return PSE.at(oz);
  return "";

}

void molekul::axes(QList<INP> xdinp) {
  glDisable(GL_LIGHTING);
  glLineWidth(3);
  for (int j=0;j<xdinp.size();j++) {
    if (xdinp[j].OrdZahl<0) continue;
    if (QString(xdinp[j].atomname).contains(QRegExp("_\\d+$",Qt::CaseInsensitive,QRegExp::RegExp))) continue;
    if (QString(xdinp[j].atomname).contains(QRegExp("'$",Qt::CaseInsensitive,QRegExp::RegExp))) continue;
/*    printf("%f %f %f\n%f %f %f\n%f %f %f\n\n",
		    xdinp[j].ax1.x, xdinp[j].ax1.y, xdinp[j].ax1.z,
		    xdinp[j].ax2.x, xdinp[j].ax2.y, xdinp[j].ax2.z,
		    xdinp[j].ax3.x, xdinp[j].ax3.y, xdinp[j].ax3.z);*/
    if ((fabs(Norm(xdinp[j].ax1)-1.0)>0.01)|| 
	(fabs(Norm(xdinp[j].ax2)-1.0)>0.01)|| 
	(fabs(Norm(xdinp[j].ax3)-1.0)>0.01))continue;
    glPushMatrix();
    glBegin(GL_LINES);
    if (xdinp[j].icor1==2) glColor4f(0.0f,1.0f,0.0f,0.5f);
    else if (xdinp[j].icor1==3) glColor4f(0.0f,0.0f,1.0f,1.0f);
    else glColor4f(1.0f,0.0f,0.0f,0.5f);
    glVertex3d(xdinp[j].kart.x,xdinp[j].kart.y,xdinp[j].kart.z);
    glVertex3d(xdinp[j].kart.x+(xdinp[j].ax1.x/2.0),
	       xdinp[j].kart.y+(xdinp[j].ax1.y/2.0),
	       xdinp[j].kart.z+(xdinp[j].ax1.z/2.0));
    
    if (xdinp[j].icor2==2) glColor4f(0.0f,1.0f,0.0f,0.5f);
    else if (xdinp[j].icor2==3) glColor4f(0.0f,0.0f,1.0f,0.5f);
    else glColor4f(1.0f,0.0f,0.0f,0.5f);
    glVertex3d(xdinp[j].kart.x,xdinp[j].kart.y,xdinp[j].kart.z);
    glVertex3d(xdinp[j].kart.x+(xdinp[j].ax2.x/2.0),
	       xdinp[j].kart.y+(xdinp[j].ax2.y/2.0),
	       xdinp[j].kart.z+(xdinp[j].ax2.z/2.0));
    
    if ((6-xdinp[j].icor2-xdinp[j].icor1)==2) glColor4f(0.0f,1.0f,0.0f,0.5f);
    else if ((6-xdinp[j].icor2-xdinp[j].icor1)==3) glColor4f(0.0f,0.0f,1.0f,0.5f);
    else glColor4f(1.0f,0.0f,0.0f,0.5f);
    glVertex3d(xdinp[j].kart.x,xdinp[j].kart.y,xdinp[j].kart.z);
    glVertex3d(xdinp[j].kart.x+(xdinp[j].ax3.x/2.0),
	       xdinp[j].kart.y+(xdinp[j].ax3.y/2.0),
	       xdinp[j].kart.z+(xdinp[j].ax3.z/2.0));
    glEnd();
    glPopMatrix();
  }
  glLineWidth(1);
  glEnable(GL_LIGHTING);
}

/*
void molekul::UnitZell2(int zz)
{

      glDisable(GL_LIGHTING);  
      glLineWidth(2);
      glPushMatrix();

      glBegin(GL_LINES);
      glColor4f(0.0f,0.0f,1.0f,1.0f);
      glVertex3d(uz0k[0],uz0k[1],uz0k[2]);
      glVertex3d(uz1k[0],uz1k[1],uz1k[2]);
      
      glColor4f(1.0f,0.0f,0.0f,1.0f);
      glVertex3d(uz0k[0],uz0k[1],uz0k[2]);
      glVertex3d(uz2k[0],uz2k[1],uz2k[2]);

      glColor4f(0.0f,1.0f,0.0f,1.0f);
      glVertex3d(uz0k[0],uz0k[1],uz0k[2]);
      glVertex3d(uz3k[0],uz3k[1],uz3k[2]);

      glColor4f(0.6f,0.7f,0.5f,1.0f);
      glVertex3d(uz1k[0],uz1k[1],uz1k[2]);
      glVertex3d(uz4k[0],uz4k[1],uz4k[2]);

      glVertex3d(uz1k[0],uz1k[1],uz1k[2]);     
      glVertex3d(uz5k[0],uz5k[1],uz5k[2]);

      glVertex3d(uz2k[0],uz2k[1],uz2k[2]);
      glVertex3d(uz4k[0],uz4k[1],uz4k[2]);

      glVertex3d(uz2k[0],uz2k[1],uz2k[2]);
      glVertex3d(uz6k[0],uz6k[1],uz6k[2]);

      glVertex3d(uz3k[0],uz3k[1],uz3k[2]);
      glVertex3d(uz5k[0],uz5k[1],uz5k[2]);

      glVertex3d(uz3k[0],uz3k[1],uz3k[2]);
      glVertex3d(uz6k[0],uz6k[1],uz6k[2]);

      glVertex3d(uz7k[0],uz7k[1],uz7k[2]);
      glVertex3d(uz5k[0],uz5k[1],uz5k[2]);
      
      glVertex3d(uz7k[0],uz7k[1],uz7k[2]);
      glVertex3d(uz4k[0],uz4k[1],uz4k[2]);
      
      glVertex3d(uz7k[0],uz7k[1],uz7k[2]);
      glVertex3d(uz6k[0],uz6k[1],uz6k[2]);
      
      glEnd();
      glEnable(GL_LIGHTING);

      glutSolidSphere(1.0,24,12);
      glDisable( GL_DEPTH_TEST );
      glColor4f(1.0f,1.0f,1.0f,1.0f); 
      glRasterPos3f(uz1k[0],uz1k[1],uz1k[2]);      
      char bez[30];
      sprintf(bez,"X%d",zz);
      if (!notext) glPrint(bez);
      glRasterPos3f(uz2k[0],uz2k[1],uz2k[2]);      
      sprintf(bez,"Y%d",zz);
      if (!notext) glPrint(bez);
      glRasterPos3f(uz3k[0],uz3k[1],uz3k[2]);      
      sprintf(bez,"Z%d",zz);
      if (!notext) glPrint(bez);
      glEnable( GL_DEPTH_TEST ); 
      glPopMatrix();     
  glLineWidth(1);

}
*/

void molekul::UnitZell(double t) {
//  printf("UnitZell %f\n",t);
  glDisable(GL_LIGHTING);
  glLineWidth(2);
      glPushMatrix();
      glBegin(GL_LINES);
      glColor4f(1.0f,0.0f,0.0f,1.0);

      glVertex3d(uz0k.x,uz0k.y,uz0k.z);
      glVertex3d(uz1k.x,uz1k.y,uz1k.z);
      
      glColor4f(0.0f,1.0f,0.0f,1.0);
      glVertex3d(uz0k.x,uz0k.y,uz0k.z);
      glVertex3d(uz2k.x,uz2k.y,uz2k.z);

      glColor4f(0.0f,0.0f,1.0f,1.0);
      glVertex3d(uz0k.x,uz0k.y,uz0k.z);
      glVertex3d(uz3k.x,uz3k.y,uz3k.z);

      glColor4f(0.6f,0.6f,0.8f,1.0);
      glVertex3d(uz1k.x,uz1k.y,uz1k.z);
      glVertex3d(uz4k.x,uz4k.y,uz4k.z);

      glVertex3d(uz1k.x,uz1k.y,uz1k.z);     
      glVertex3d(uz5k.x,uz5k.y,uz5k.z);

      glVertex3d(uz2k.x,uz2k.y,uz2k.z);
      glVertex3d(uz4k.x,uz4k.y,uz4k.z);

      glVertex3d(uz2k.x,uz2k.y,uz2k.z);
      glVertex3d(uz6k.x,uz6k.y,uz6k.z);

      glVertex3d(uz3k.x,uz3k.y,uz3k.z);
      glVertex3d(uz5k.x,uz5k.y,uz5k.z);

      glVertex3d(uz3k.x,uz3k.y,uz3k.z);
      glVertex3d(uz6k.x,uz6k.y,uz6k.z);

      glVertex3d(uz7k.x,uz7k.y,uz7k.z);
      glVertex3d(uz5k.x,uz5k.y,uz5k.z);
      
      glVertex3d(uz7k.x,uz7k.y,uz7k.z);
      glVertex3d(uz4k.x,uz4k.y,uz4k.z);
      
      glVertex3d(uz7k.x,uz7k.y,uz7k.z);
      glVertex3d(uz6k.x,uz6k.y,uz6k.z);
      
      glEnd();
  //    printf("%d\n",ccc.size());
      bool com=zelle.commensurate;
      zelle.commensurate=false;
      glLineWidth(1);
      for (int i=0; i<ccc.size(); i++){
//        printf("ccc!!%d\n",i);
        Modulat *m=new Modulat(0,0,0,0,0,0);
        m->mol=this;
        m->iamcomp=i+2;
        int ncc=0;
        V3 uccmp[8];
        for (int h=0; h<2; h++)
        for (int k=0; k<2; k++)
        for (int l=0; l<2; l++){
        m->frac0=V3(h,k,l);
        uccmp[ncc]=m->kart(t);
 //       printf("%d %d %d %d %f %f %f\n",h,k,l,ncc,uccmp[ncc].x,uccmp[ncc].y,uccmp[ncc].z);
        ncc++;
        }
      glBegin(GL_LINES);
      glColor4f(1.0f,0.2f,0.2f,0.3);

      glVertex3d(uccmp[0].x,uccmp[0].y,uccmp[0].z);
      glVertex3d(uccmp[4].x,uccmp[4].y,uccmp[4].z);
      
      glColor4f(0.2f,1.0f,0.2f,0.3);
      glVertex3d(uccmp[0].x,uccmp[0].y,uccmp[0].z);
      glVertex3d(uccmp[2].x,uccmp[2].y,uccmp[2].z);

      glColor4f(0.2f,0.2f,1.0f,0.3);
      glVertex3d(uccmp[0].x,uccmp[0].y,uccmp[0].z);
      glVertex3d(uccmp[1].x,uccmp[1].y,uccmp[1].z);

      glColor4f(0.8f,0.8f,1.0f,0.3);
      glVertex3d(uccmp[1].x,uccmp[1].y,uccmp[1].z);
      glVertex3d(uccmp[3].x,uccmp[3].y,uccmp[3].z);

      glVertex3d(uccmp[1].x,uccmp[1].y,uccmp[1].z);     
      glVertex3d(uccmp[5].x,uccmp[5].y,uccmp[5].z);

      glVertex3d(uccmp[2].x,uccmp[2].y,uccmp[2].z);
      glVertex3d(uccmp[3].x,uccmp[3].y,uccmp[3].z);

      glVertex3d(uccmp[2].x,uccmp[2].y,uccmp[2].z);
      glVertex3d(uccmp[6].x,uccmp[6].y,uccmp[6].z);

      glVertex3d(uccmp[3].x,uccmp[3].y,uccmp[3].z);
      glVertex3d(uccmp[7].x,uccmp[7].y,uccmp[7].z);

      glVertex3d(uccmp[4].x,uccmp[4].y,uccmp[4].z);
      glVertex3d(uccmp[5].x,uccmp[5].y,uccmp[5].z);

      glVertex3d(uccmp[4].x,uccmp[4].y,uccmp[4].z);
      glVertex3d(uccmp[6].x,uccmp[6].y,uccmp[6].z);
      
      glVertex3d(uccmp[7].x,uccmp[7].y,uccmp[7].z);
      glVertex3d(uccmp[5].x,uccmp[5].y,uccmp[5].z);
      
      glVertex3d(uccmp[7].x,uccmp[7].y,uccmp[7].z);
      glVertex3d(uccmp[6].x,uccmp[6].y,uccmp[6].z);
      
      glEnd();
      }
      zelle.commensurate=com;
      
//      glDisable( GL_DEPTH_TEST );
//      glColor4f(1.0f,1.0f,1.0f,1.0f); 
/*
      cubeGL->renderText( uz1k.x,uz1k.y,uz1k.z, "X",myFont);
      cubeGL->renderText( uz2k.x,uz2k.y,uz2k.z, "Y",myFont);
      cubeGL->renderText( uz3k.x,uz3k.y,uz3k.z, "Z",myFont);
*/
//      glEnable( GL_DEPTH_TEST ); 
      glPopMatrix();     
  glLineWidth(1);
  glEnable(GL_LIGHTING);
}

void molekul::make_bonds(QList<INP> xdinp){
  if (xdinp.isEmpty()) return;
  double gg,soll_abst;
  bcnt=0;
  bd=NULL;
  int msiz=(xdinp.size()*10);
  if (NULL==(bd=(bindi*)malloc(sizeof(bindi)*msiz)))return;
  for (int i=0;i<xdinp.size();i++) {
      //printf("i=%d sg=%d part=%d\n",i,xdinp[i].sg,xdinp[i].part);
    for (int j=0;j<xdinp.size();j++) {
      if (i==j) continue;



      if((xdinp[i].OrdZahl<0)||(xdinp[j].OrdZahl<0)) continue;
      if (((xdinp[i].part<0)||(xdinp[j].part<0))&&((xdinp[i].sg!=xdinp[j].sg)||((xdinp[i].part*xdinp[j].part)&&(xdinp[i].part!=xdinp[j].part)))) continue; //part negative
      if ((xdinp[i].part>0)&&(xdinp[j].part>0)&&(xdinp[i].part!=xdinp[j].part)) continue; //different part
      if ((xdinp[i].OrdZahl<83)&&(xdinp[j].OrdZahl<83)&&(xdinp[i].OrdZahl>=0)&&(xdinp[j].OrdZahl>=0)){
	soll_abst=((Kovalenz_Radien[xdinp[i].OrdZahl]+
		    Kovalenz_Radien[xdinp[j].OrdZahl])
		   -(0.08*fabs((double)ElNeg[xdinp[i].OrdZahl]
			       -ElNeg[xdinp[j].OrdZahl])))*1.1;
	gg=100.0*sqrt( Distance(xdinp[i].kart,xdinp[j].kart));
	if (gg<soll_abst) {
	  bd[bcnt].a=i;	
	  bd[bcnt].e=j;
/*	    printf("%s[%d](%d,%d)-%s[%d](%d,%d) %d\n",
			    xdinp[bd[bcnt].a].atomname,
			    bd[bcnt].a,
			    xdinp[bd[bcnt].a].sg,
			    xdinp[bd[bcnt].a].part,
			    xdinp[bd[bcnt].e].atomname,
			    bd[bcnt].e,
			    xdinp[bd[bcnt].e].sg,
			    xdinp[bd[bcnt].e].part,
			    bcnt);*/
	  bcnt++;
          if (bcnt>=msiz){
          msiz+=10;
          bd=(bindi*)realloc(bd,sizeof(bindi)*msiz);  
          }
	}//bindung
      }//Ordnungzahl-ok
    }//j
  }//i
  bd=(bindi*)realloc(bd,sizeof(bindi)*bcnt);  
  bonds_made=1;
}
void molekul::make_bonds(QList<Modulat> xdinp,double t){
  if (xdinp.isEmpty()) return;
//  printf("make_bonds %g\n",t);
  int msiz=(xdinp.size()*10);
  double gg,soll_abst;
  bcnt=0;
  if (bd!=NULL) free(bd);
  bd=NULL;
  if (NULL==(bd=(bindi*)malloc(sizeof(bindi)*msiz)))return;
  for (int i=0;i<xdinp.size();i++) {
      //printf("i=%d sg=%d part=%d\n",i,xdinp[i].sg,xdinp[i].part);
    for (int j=i+1;j<xdinp.size();j++) {
      if (i==j) continue;
      if((xdinp[i].OrdZahl<0)||(xdinp[j].OrdZahl<0)) continue;
      if((xdinp[i].OrdZahl==0)&&(xdinp[j].OrdZahl==0)) continue;

      if ((!bondsBetweenSGs->isChecked())&&(xdinp[i].sg!=xdinp[j].sg))continue;
//      if (((xdinp[i].part<0)||(xdinp[j].part<0))&&((xdinp[i].sg!=xdinp[j].sg)||((xdinp[i].part*xdinp[j].part)&&(xdinp[i].part!=xdinp[j].part)))) continue; //part negative
//      if ((xdinp[i].part>0)&&(xdinp[j].part>0)&&(xdinp[i].part!=xdinp[j].part)) continue; //different part
      double o2=xdinp[i].occupancy(t)*xdinp[j].occupancy(t);
      if (o2<0.1) continue;
      if ((xdinp[i].OrdZahl<83)&&(xdinp[j].OrdZahl<83)&&(xdinp[i].OrdZahl>=0)&&(xdinp[j].OrdZahl>=0)){
	soll_abst=((Kovalenz_Radien[xdinp[i].OrdZahl]+
		    Kovalenz_Radien[xdinp[j].OrdZahl])
		   -(0.08*fabs((double)ElNeg[xdinp[i].OrdZahl]
                   -ElNeg[xdinp[j].OrdZahl])))*1.1;
	gg=100.0*sqrt( Distance(xdinp[i].kart(t),xdinp[j].kart(t)));
	if (gg<soll_abst) {
	  bd[bcnt].a=i;	
	  bd[bcnt].e=j;
/*	    printf("%s[%d](%d,%d)-%s[%d](%d,%d) %d\n",
			    xdinp[bd[bcnt].a].atomname,
			    bd[bcnt].a,
			    xdinp[bd[bcnt].a].sg,
			    xdinp[bd[bcnt].a].part,
			    xdinp[bd[bcnt].e].atomname,
			    bd[bcnt].e,
			    xdinp[bd[bcnt].e].sg,
			    xdinp[bd[bcnt].e].part,
			    bcnt);*/
	  bcnt++;
          if (bcnt>=msiz){
          msiz+=10;
          bd=(bindi*)realloc(bd,sizeof(bindi)*msiz);  
          }
	}//bindung
      }//Ordnungzahl-ok
    }//j
  }//i
  bd=(bindi*)realloc(bd,sizeof(bindi)*(bcnt+10));
  bonds_made=1;
  mbonds_last_t=t;
}

/*void molekul::cyclsort(PolyEder & p){
    int mini=qMin(p.ai,p.bi);
    int dum1,dum2;
    mini=qMin(mini,p.ci);
    if (mini==p.ai){
 //richtig rum
    }
    else if(mini==p.bi){
        dum1=p.ai;
        p.ai=p.bi;
        p.bi=p.ci;
        p.ci=dum1;
    }
    else{
        dum1=p.bi;
        dum2=p.ai;
        p.ai=p.ci;
        p.bi=dum2;
        p.ci=dum1;
    }
}// */

int molekul::findPoly(int zi, PolyEder p,QList<INP> xd){
    int answer=-1;
    //GLfloat d;
    for (int i=0; i<polyeders.size(); i++){
//        if (zi==polyeders.at(i).zi) printf("%d %g\n",zi,fabsf(p.norm*polyeders.at(i).norm));
        if ((zi==polyeders.at(i).zi)&&(0.7f<fabsf(p.norm*polyeders.at(i).norm))){
            if (0.1<(polyeders.at(i).mid-xd[zi].kart)*(p.mid-xd[zi].kart)) {
                /*printf("polyeders.at(i).mid %g %g %g polyeders.at(i).norm %g %g %g\n",
                       polyeders.at(i).mid.x,polyeders.at(i).mid.y,polyeders.at(i).mid.z,
                       polyeders.at(i).norm.x,polyeders.at(i).norm.y,polyeders.at(i).norm.z
                       );*/
                return i;
            }
        }
    }
    return answer;
}

void molekul::planes(QList<INP> xd){
  QList<V3> allNormals,uniqNormals;
/*  QMap<int,QList<int>> inplane;
  V3 n,zent;
  for (int i=0; i<xd.size(); i++){
    zent=xd[i].kart;
    if (Knopf[i].lz<2)continue;
    for (int j=0; j<Knopf[i].lz;j++){
      int di=Knopf[i].lig[j],da=Knopf[i].lig[(j+1)%Knopf[i].lz];
      n=Normalize((xd[di].kart-zent)%(xd[da].kart-zent));
  //    printf("%6s %6s %6s %d %d %d\n",xd[i].atomname,xd[da].atomname,xd[di].atomname,i,da,di);
      double max=0.0;
      for (int k=0; k<allNormals.size(); k++) max=fmax(max,fabs(n*allNormals.at(k)));
      allNormals.append(n);
      for (int k=0; k<uniqNormals.size(); k++) if (fabs(n*uniqNormals.at(k))>0.99) {
//        printf("Mx%f u%d \n",n*uniqNormals.at(k),k);
        if (!inplane[k].contains(i)) inplane[k].append(i);
        if (!inplane[k].contains(di)) inplane[k].append(di);
        if (!inplane[k].contains(da)) inplane[k].append(da);
        break;
      } 
      if (max>0.99) continue;
//      printf("mx%f u%d \n",max,uniqNormals.size());
      
      int k=uniqNormals.size();
      if (!inplane[k].contains(i)) inplane[k].append(i);
      if (!inplane[k].contains(di)) inplane[k].append(di);
      if (!inplane[k].contains(da)) inplane[k].append(da);
      uniqNormals.append(n);

    }
  }
  printf("%d all normals, %d unique \n",allNormals.size(),uniqNormals.size());
  for (int k=0; k<uniqNormals.size(); k++)  {
    V3 mii=V3(0,0,0);
    for (int l=0; l<inplane[k].size(); l++) {mii+= xd[inplane[k].at(l)].kart;printf("%s ",xd[inplane[k].at(l)].atomname);}
    mii*=1.0/inplane[k].size();
     int ok=0;
     for (int w=0; w<xd.size();w++){
       if (inplane[k].contains(w)){
         int du=3;
         for (int j=0; j<Knopf[w].lz;j++){
           if (inplane[k].contains(Knopf[w].lig[j])) du--;
         }
         if (du==1) ok++;
       }
     }
     printf("ok? %d\n",ok);
     if (ok==inplane[k].size()) printf(" %f %f %f origin={%f,%f,%f} \n",uniqNormals.at(k).x,uniqNormals.at(k).y,uniqNormals.at(k).z,
         mii.x,
         mii.y,
         mii.z
         );
  }
  */
}

void molekul::make_polyeder(QList<INP> xd){
    printf("make_polyeder\n");
    if (!knopf_made) make_knopf(xd);
 //   planes(xd);
    V3 zent;/*
    extern QList<INP> asymmUnit;
    INP newAtom;
    newAtom.part=0;
    newAtom.sg=0;
    newAtom.OrdZahl=-3;
    sprintf(newAtom.atomname,"CP00");*/
    PolyEder polyvecs;
    polyeders.clear();
    int index;
    double vol,r,soll_abst,d,w;//,mr;
    for (int i=0; i<xd.size(); i++){
        if (Knopf[i].lz<4)continue;
        zent=xd[i].kart;
        //if (ElNeg[xd[i].OrdZahl]>240) continue;
        soll_abst=((Kovalenz_Radien[xd[i].OrdZahl]+Kovalenz_Radien[xd[Knopf[i].lig[0]].OrdZahl])
               -(0.08*fabs((double)ElNeg[xd[i].OrdZahl]-ElNeg[xd[Knopf[i].lig[0]].OrdZahl])))*1.1;
        soll_abst*=0.01;
        //soll_abst*=soll_abst;
        for (int j=0; j<Knopf[i].lz;j++){
            for (int k=j+1;k<Knopf[i].lz;k++){
                for (int l=k+1;l<Knopf[i].lz;l++){
                    polyvecs.norm=Normalize((xd[Knopf[i].lig[j]].kart-xd[Knopf[i].lig[k]].kart)%(xd[Knopf[i].lig[l]].kart-xd[Knopf[i].lig[k]].kart));

                    vol=((xd[Knopf[i].lig[j]].kart-zent)%(xd[Knopf[i].lig[k]].kart-zent))*(xd[Knopf[i].lig[l]].kart-zent);

                    if (fabs(vol)<0.2) continue;
                    //if (d>0.3*soll_abst) 
                    double r1,r2,r3;
/*                    r= sqrt(Distance(xd[Knopf[i].lig[j]].kart,xd[Knopf[i].lig[k]].kart));//soll_abst;
                    r+=sqrt(Distance(xd[Knopf[i].lig[l]].kart,xd[Knopf[i].lig[k]].kart));//soll_abst;
                    r+=sqrt(Distance(xd[Knopf[i].lig[j]].kart,xd[Knopf[i].lig[l]].kart));//soll_abst;*/
                    r =r1=sqrt(Distance(xd[Knopf[i].lig[j]].kart,zent));
                    r+=r2=sqrt(Distance(xd[Knopf[i].lig[l]].kart,zent));
                    r+=r3=sqrt(Distance(xd[Knopf[i].lig[k]].kart,zent));


                    polyvecs.edge.clear();
                    polyvecs.mid=xd[Knopf[i].lig[j]].kart+xd[Knopf[i].lig[k]].kart+xd[Knopf[i].lig[l]].kart;
                    polyvecs.mid*=1.0/3.0;
                    d=polyvecs.norm*(polyvecs.mid-zent);
                    w=Normalize(polyvecs.mid)*polyvecs.norm;
//                    if (((d/soll_abst)<0.45)||(w<0.8)) continue;
           //         printf("!!%-9s %g, soll%g %g vol%g %g   \n",xd[i].atomname,d,r/3.0, 3.0*d/r,vol,w);
                    /*newAtom.kart=polyvecs.mid;
                    kart2frac(newAtom.kart,newAtom.frac);
                    asymmUnit.append(newAtom);
*/
                    polyvecs.zi=i;
//                    index=-1;
                    index=findPoly(i,polyvecs,xd);
                    if (index!=-1){
                        //printf("foundpoly [%d]\n",index);
                        polyvecs=polyeders[index];
                       // printf("foundpoly %d %d\n",i,polyvecs.edge.size());
                        if (!polyvecs.edge.contains(Knopf[i].lig[j])) polyvecs.edge.append(Knopf[i].lig[j]);
                        if (!polyvecs.edge.contains(Knopf[i].lig[k])) polyvecs.edge.append(Knopf[i].lig[k]);
                        if (!polyvecs.edge.contains(Knopf[i].lig[l])) polyvecs.edge.append(Knopf[i].lig[l]);
                        polyvecs.mid=V3(0,0,0);
                        for (int m=0;m<polyvecs.edge.size();m++){
                            polyvecs.mid+=xd[polyvecs.edge.at(m)].kart;
                    //      printf("%4s ",xd[polyvecs.edge.at(m)].atomname);

                        }
                      //  printf("\n");
                        if (polyvecs.edge.size())  polyvecs.mid*=1.0/polyvecs.edge.size();
                        polyvecs.norm=Normalize(polyvecs.mid-zent);
                        polyvecs.umfang=r;
                        polyeders[index]=polyvecs;
                    }else {
                        polyvecs.mid=V3(0,0,0);
                        polyvecs.edge.append(Knopf[i].lig[j]);
                        polyvecs.edge.append(Knopf[i].lig[k]);
                        polyvecs.edge.append(Knopf[i].lig[l]);
                        for (int m=0;m<polyvecs.edge.size();m++)
                            polyvecs.mid+=xd[polyvecs.edge.at(m)].kart;
                        if (polyvecs.edge.size())  polyvecs.mid*=1.0/polyvecs.edge.size();
                        polyvecs.norm=Normalize(polyvecs.mid-zent);
                        polyvecs.umfang=r;
                        polyeders.append(polyvecs);
                    }

                }
            }
        }
      //  printf("----\n");
    }    
    minvolpol=10e38;
    maxvolpol=-10e38;
    for (int i=0;i<polyeders.size();i++){
        minvolpol=qMin(minvolpol,polyeders.at(i).umfang);
        maxvolpol=qMax(maxvolpol,polyeders.at(i).umfang);
        if (polyeders.at(i).edge.size()>3){
            int kk=polyeders.at(i).edge.size();
            for (int nn=1;nn<polyeders.at(i).edge.size()-1;nn++){
            V3 start=xd[polyeders.at(i).edge.at(0)].kart;
            for (int j=1; j<kk;j++){
                if (Distance(start,xd[polyeders.at(i).edge.at(j)].kart)>Distance(start,xd[polyeders.at(i).edge.at((j+1)%kk)].kart)){
                //    printf("swapping: %s <=> %s %d %d\n",xd[polyeders.at(i).edge.at(j)].atomname,xd[polyeders.at(i).edge.at((j+1)%kk)].atomname,j,(j+1)%kk);
                    polyeders[i].edge.swap(j,(j+1)%kk);
                //    printf("next %s \n",xd[polyeders.at(i).edge.at(j)].atomname);
                }
                /*else {printf("not swapping: %s <=> %s %d %d %g %g\n",xd[polyeders.at(i).edge.at(j)].atomname,xd[polyeders.at(i).edge.at((j+1)%kk)].atomname,j,(j+1)%kk,
                            Distance(start,xd[polyeders.at(i).edge.at(j)].kart),Distance(start,xd[polyeders.at(i).edge.at((j+1)%kk)].kart));}// */
                start=xd[polyeders.at(i).edge.at(j)].kart;
            }
            }
            for (int j=0; j<kk;j++){
            //    printf("[%4s]",xd[polyeders.at(i).edge.at(j)].atomname);
            }
           // printf("\n");
    }
    }
    printf("polyeders.size() %d\n",polyeders.size());
}


void molekul::make_knopf(QList<INP> xd){


  if (!bonds_made) make_bonds(xd);
  if (!knopf_made) {
    Knopf=(knpf*)malloc(sizeof(knpf)*xd.size());

    for (int i=0; i<xd.size(); i++) Knopf[i].lz=0;
    for (int i=0;i<bcnt;i++){


      Knopf[bd[i].a].lig[Knopf[bd[i].a].lz++]=bd[i].e;
      Knopf[bd[i].a].bnr[Knopf[bd[i].a].lz-1]=i;
      Knopf[bd[i].a].bgrad[Knopf[bd[i].a].lz-1]=(((Kovalenz_Radien[xd[bd[i].a].OrdZahl]/100.0+
						   Kovalenz_Radien[xd[bd[i].e].OrdZahl]/100.0)
						  -(0.08*fabs((ElNeg[xd[bd[i].e].OrdZahl]-
							       ElNeg[xd[bd[i].a].OrdZahl])/100.0)))-
						 sqrt(Distance (xd[bd[i].a].kart, xd[bd[i].e].kart)));
    }
  }


  extern QList<INP> xdinp;
  for (int i=0; i<xdinp.size(); i++) {
    xdinp[i].firstNeighbors=Knopf[i].lz;
    xdinp[i].secondNeighbors=0;
    for (int j=0;j<Knopf[i].lz;j++){
      xdinp[i].secondNeighbors+=Knopf[Knopf[i].lig[j]].lz;

    }
    xdinp[i].secondNeighbors-=xdinp[i].firstNeighbors;

  }
  knopf_made=1;
  make_polyeder(xd);
}
void molekul::entknoten(){
  if (knopf_made){
    free(Knopf);
  }
}
void molekul::countMols(QList<INP> & xdinp){
  for (int i=0; i<xdinp.size();i++)
    xdinp[i].molindex=0;
  int maxmol=1;
  xdinp[0].molindex=1;
  int nochjemand=0;
  int nextmol=0;
  do {//bis alle atome einen molindex > 0 haben 
    nextmol=0;
    do {//bis kein atom mehr in diesem molekul zu finden ist
      nochjemand=0;
      for (int i=1;i<xdinp.size();i++){//atom 0 ist immer in mol 1 daher von 1 zaehlen
	if (xdinp[i].OrdZahl<0) continue;
	for (int j=0; j< Knopf[i].lz;j++){
	  if (xdinp[Knopf[i].lig[j]].OrdZahl<0) continue;
	  if ((xdinp[Knopf[i].lig[j]].molindex==maxmol)&&(xdinp[i].molindex==0)) {
	    //alle nachbarn anschauen ob sie ein molindex == maxmol haben falls das
	    //betrachtete atom noch nicht zugeordnet ist.

	    xdinp[i].molindex=maxmol;
	    nochjemand++;//wir haben nochjemand gefunden der im selben molekuel noch keinen molindex > 0 hatte
	  }
	}
      }
    }while (nochjemand);
    for (int i=0; i<xdinp.size();i++) //gibt es noch atome die molendex == 0 haben dann sind dise im nextmol
      if ((xdinp[i].OrdZahl>=0)&&(xdinp[i].molindex==0)) {
	nextmol=i;
	break;
      }
    if (nextmol) xdinp[nextmol].molindex=++maxmol;//maxmol um 1 ergoehen und DANN an das gefundene atom zuweisen.
    
  }while (nextmol);
  printf ("The structure contains %d molecules\n",maxmol);
}
#define ROTATE(a,i,j,k,l) g=a[i][j];h=a[k][l];a[i][j]=g-s*(h+g*tau); a[k][l]=h+s*(g-h*tau);
//NumericalRecepies....
double * molekul::jacobi2(const Matrix &uij, V3 &ev) {

  int j,iq,ip,i,n=3,nrot;
  double tresh=0,theta,tau,t,sm,s,h,g,c;
  double a[3][3],b[3],z[3],v[3][3],d[3];
  a[0][0]=uij.m11;
  a[0][1]=uij.m12;
  a[0][2]=uij.m13;
  a[1][0]=uij.m21;
  a[1][1]=uij.m22;
  a[1][2]=uij.m23;
  a[2][0]=uij.m31;
  a[2][1]=uij.m32;
  a[2][2]=uij.m33;
  static double erg[4]={0.0,1.0,0.0,0.0};
  for (ip=1;ip<=n;ip++) {
    for (iq=1;iq<=n;iq++) v[ip-1][iq-1]=0.0;
    v[ip-1][ip-1]=1.0;
  }
  for (ip=1;ip<=n;ip++) {
    b[ip-1]=d[ip-1]=a[ip-1][ip-1];
    z[ip-1]=0.0;
  }
  nrot=0;
  for (i=1;i<=150;i++) {
    sm=0.0;
    for (ip=1;ip<=n-1;ip++) {
      for (iq=ip+1;iq<=n;iq++)
    sm += fabs(a[ip-1][iq-1]);
    }

    //printf("sm =%20.19f\n",sm);

    if (float(sm) < tresh) {
      if ((v[0][0]+v[1][1]+v[2][2])!=3.0) {
      erg[0]=acos((v[0][0]+v[1][1]+v[2][2]-1.0)/2.0);
      erg[1]=(v[2][1]-v[1][2])/(2.0*sin(erg[0]));
      erg[2]=(v[0][2]-v[2][0])/(2.0*sin(erg[0]));
      erg[3]=(v[1][0]-v[0][1])/(2.0*sin(erg[0]));
      erg[0]*=180.0/M_PI;}
      else {erg[0]=0.0;erg[1]=1.0;erg[2]=0.0;erg[3]=0.0; }
      //printf("%d??ERG:%f %f %f %f\n",i,Ato4d(erg));
      /*
      printf("=%d======================================\n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f\n========================================\n",i,
              d[0],d[1],d[2],v[0][0],v[0][1],v[0][2]
          ,v[1][0],v[1][1],v[1][2]
          ,v[2][0],v[2][1],v[2][2]
          );*/
     ev=V3(d[0],d[1],d[2]);
     return (double*) erg;
    }
    if (i < 4) tresh=0.00001;
    else tresh=0.0001;
    for (ip=1;ip<=n-1;ip++) {
      for (iq=ip+1;iq<=n;iq++) {
    //printf("\np:%i q:%i i:%i nrot:%i\n",ip,iq,i,nrot);
    g=100.0*fabs(a[ip-1][iq-1]);
    if ((i > 4) && ((fabs(d[ip-1])+g) == fabs(d[ip-1])) && ((fabs(d[iq-1])+g) == fabs(d[iq-1]))) {a[ip-1][iq-1]=0.0;}
    else if (fabs(a[ip-1][iq-1]) >= tresh) {
      h=d[iq-1]-d[ip-1];
      if ((fabs(h)+g) == fabs(h)) {t=(a[ip-1][iq-1])/h; }
      else { theta=0.5*h/(a[ip-1][iq-1]);
      t=1.0/(fabs(theta)+sqrt(1.0+theta*theta));
      if (theta < 0.0) {t = -1.0*t;}
      }
      c=1.0/sqrt(1+t*t);
      s=t*c;
      tau=s/(1.0+c);
      h=t*a[ip-1][iq-1];
      z[ip-1] -= h;
      z[iq-1] += h;
      d[ip-1] -= h;
      d[iq-1] += h;
      a[ip-1][iq-1]=0.0;
      for (j=1;j<=ip-1;j++) {
           ROTATE(a,j-1,ip-1,j-1,iq-1)
          //printf("%i %i %i %i",j,ip,j,iq);
          }
      for (j=ip+1;j<=iq-1;j++) {
           ROTATE(a,ip-1,j-1,j-1,iq-1)
          //printf("%i %i %i %i ",ip,j,j,iq);
          }
      for (j=iq+1;j<=n;j++) {
           ROTATE(a,ip-1,j-1,iq-1,j-1)
          //printf("%i %i %i %i",ip,j,iq,j);
          }
      for (j=1;j<=n;j++) {
           ROTATE(v,j-1,ip-1,j-1,iq-1)
          }
      ++(nrot);
      //    printf("U|\n%f %f %f  \n%f %f %f\n%f %f %f\nV|\n%f %f %f  \n%f %f %f\n%f %f %f\n\n",a[0][0],a[1][0],a[2][0],a[0][1],a[1][1],a[2][1],a[0][2],a[1][2],a[2][2],v[0][0],v[1][0],v[2][0],v[0][1],v[1][1],v[2][1],v[0][2],v[1][2],v[2][2]);
    } //else ;//printf("nix:%f p%i q%i",fabs(a[ip-1][iq-1]),ip,iq);
      }
    }
    for (ip=1;ip<=n;ip++) {
      b[ip-1] += z[ip-1];
      d[ip-1] =b[ip-1];
      z[ip-1] =0.0;
    }
  }
  erg[0]=acos((v[0][0]+v[1][1]+v[2][2]-1.0)/2.0);
  if (erg[0]==0) {
    erg[1]=1.0;
    erg[2]=0.0;
    erg[3]=0.0;
  }else{
  erg[1]=(v[2][1]-v[1][2])/(2.0*sin(erg[0]));
  erg[2]=(v[0][2]-v[2][0])/(2.0*sin(erg[0]));
  erg[3]=(v[1][0]-v[0][1])/(2.0*sin(erg[0]));
  erg[0]*=180.0/M_PI;
  }
  /*printf("=%d=======================================\n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f \n%8.5f %8.5f %8.5f\n========================================\n",i,
          d[0],d[1],d[2],v[0][0],v[0][1],v[0][2]
          ,v[1][0],v[1][1],v[1][2]
          ,v[2][0],v[2][1],v[2][2]

          );*/
  ev=V3(d[0],d[1],d[2]);
 return (double*)erg;
}
void molekul::loadSettings(){
    QSettings einstellung( QSettings::IniFormat, QSettings::UserScope ,"Christian_B._Huebschle","MoleCoolQt" );
    einstellung.beginGroup("Version 0.1");
    ffmpegexe=einstellung.value("FFMPEG.EXE",ffmpegexe).toString();
    pseSize=einstellung.value("FontSize",10).toInt();
    LOD=einstellung.value("LevelOfDetail",3).toInt();
    tubifiedAtoms=einstellung.value("tubes").toBool();
    bondColorStyle=einstellung.value("singleColorBonds").toBool();
    QVariant variant;
    qPeakRad=einstellung.value("QPeaksRadius",qPeakRad).toDouble();
    CPRad=einstellung.value("CPRadius",CPRad).toDouble();  
      if (einstellung.contains("bondColor")){
        variant = einstellung.value("bondColor");
        bondColor=variant.value<QColor>();
      }else{bondColor=QColor("silver");}
    if ((einstellung.value("bondStrength").toDouble())>0.001)
        bondStrength=einstellung.value("bondStrength").toDouble();

    int acsize = einstellung.beginReadArray("AtomColors");
    for (int i = 0; i < acsize; ++i) {
      einstellung.setArrayIndex(i);
      Acol[i-1][0] = (GLfloat)einstellung.value("red"   ).toDouble();
      Acol[i-1][1] = (GLfloat)einstellung.value("green" ).toDouble();
      Acol[i-1][2] = (GLfloat)einstellung.value("blue"  ).toDouble();
      Acol[i-1][3] = (GLfloat)einstellung.value("alpha" ).toDouble();
    }
    einstellung.endArray();
    acsize = einstellung.beginReadArray("AtomStyles");
    for (int i = 0; i < acsize; ++i) {
      einstellung.setArrayIndex(i);
      aStyle[i-1] = einstellung.value("Style").toInt();
    }
    einstellung.endArray();
    acsize = einstellung.beginReadArray("CovaleceRadii");
    for (int i = 0; i < acsize; ++i) {
      einstellung.setArrayIndex(i);
      Kovalenz_Radien[i-1] = einstellung.value("Radius").toInt();
    }
    einstellung.endArray();

    acsize = einstellung.beginReadArray("BallRadii");
    for (int i = 0; i < acsize; ++i) {
      einstellung.setArrayIndex(i);
      arad[i-1]=(GLfloat)einstellung.value("Radius").toDouble();
    }
    einstellung.endArray();
}
#define Ato4d(arr)       arr[0], arr[1], arr[2], arr[3]
#include <QGLWidget>

void molekul::modulated(double t,QList<Modulat> mato,int draw,double steps) {
  const int dr_atoms =1;
  const int dr_bonds =2;
  const int dr_unit =4;
  const int dr_adp =8;
//  const int dr_la =16;

  if (draw&dr_atoms) {
    for  (int i=0; i<mato.size();i++){
      double occ=mato[i].occupancy(t);
      if (occ<0.1) continue; 
      int myStyle=aStyle[mato[i].OrdZahl];
      int myAdp=(myStyle&ATOM_STYLE_NOADP)?0:(draw&dr_adp);
      glPushMatrix();
      bool out=false;
      V3 pos=mato[i].kart(t,&out);
      if ((!ccc.isEmpty())&&(!zelle.commensurate)&&(out)) continue;
      int nonPositiveDefinite=0;
      //int proba=50;

      //     if (i==2) printf("%-8s %9g %9g %9g at t=%g\n",mato[i].atomname,pos.x,pos.y,pos.z,t);
      double rad=(mato[i].OrdZahl>=0)?arad[mato[i].OrdZahl]:0.15;
      glTranslated(pos.x,pos.y,pos.z);
      if (myAdp){
        Matrix u=mato[i].u(t);
        V3 ev=V3(0,0,0);
        double *arr=jacobi2(u,ev);
        if ((ev.x>0)&&(ev.y>0)&&(ev.z>0)){
          nonPositiveDefinite=0;
          glRotated(Ato4d(arr));
          double psc=1.0;
          // if (atom.at(i).part==666) psc*=1.2;
          switch (proba ) {
            case 10 :{ glScaled(0.76*sqrt(ev.x)*psc,0.76*sqrt(ev.y)*psc,0.76*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 10% Wahrscheinlichkeit
            case 30 :{ glScaled(1.19*sqrt(ev.x)*psc,1.19*sqrt(ev.y)*psc,1.19*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 30% Wahrscheinlichkeit
            case 50 :{ glScaled(1.54*sqrt(ev.x)*psc,1.54*sqrt(ev.y)*psc,1.54*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 50% Wahrscheinlichkeit
            case 70 :{ glScaled(1.91*sqrt(ev.x)*psc,1.91*sqrt(ev.y)*psc,1.91*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 70% Wahrscheinlichkeit
            case 90 :{ glScaled(2.50*sqrt(ev.x)*psc,2.50*sqrt(ev.y)*psc,2.50*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 90% Wahrscheinlichkeit
            default: ;
          }
        }else {nonPositiveDefinite=1;}
      }else glScaled(rad,rad,rad);
      GLUquadricObj *q = gluNewQuadric();
      gluQuadricNormals(q, GL_SMOOTH);   
      glColor4fv(Acol[mato[i].OrdZahl]); 
      if (!nonPositiveDefinite) sphere(0);
      else cube(rad*.25);

      glPopMatrix();
    }
  }//dr_atoms
  if (draw&dr_bonds){
    glPushMatrix();
    glEnable(GL_BLEND);
    glDisable(GL_LIGHTING);
    glLineWidth(1.5);
    glBegin(GL_LINES);
    glColor3f(0.5,0.3,0.3);
//    printf("bonds_made %d t-mbonds_last_t %g t= %g\n",bonds_made,t-mbonds_last_t,t);
    if ((!bonds_made)||(fabs(t-mbonds_last_t)>=(steps)))
      make_bonds(mato,t);
/*    V3 beg,end;
    double soll_abst;
    for  (int i=0; i<mato.size();i++)
      for  (int j=i+1; j<mato.size();j++) {
        beg=mato[i].kart(t);
        end=mato[j].kart(t); 
        soll_abst=((Kovalenz_Radien[mato[i].OrdZahl]+
              Kovalenz_Radien[mato[j].OrdZahl]))*0.011;
        soll_abst*=soll_abst;
        if (soll_abst>Distance(beg,end)){
          glVertex3d(beg.x, beg.y, beg.z);
          glVertex3d(end.x, end.y, end.z);
        }
      }
//      */
    V3 beg,end;
    bool out1=false, out2=false;
    for (int k=0;k<bcnt;k++){
        beg=mato[bd[k].a].kart(t,&out1);
        end=mato[bd[k].e].kart(t,&out2);
        if ((!ccc.isEmpty())&&(!zelle.commensurate)&&(out1)) continue;
        if ((!ccc.isEmpty())&&(!zelle.commensurate)&&(out2)) continue;
        glVertex3d(beg.x, beg.y, beg.z);
        glVertex3d(end.x, end.y, end.z);
    }
    glEnd();
    glLineWidth(1);
    glPopMatrix();
  }
  if (draw&dr_unit){
    glPushMatrix();
    UnitZell(t);
    glEnable(GL_LIGHTING);    
    glDisable(GL_BLEND);
    glPopMatrix();
  }
}

void molekul::readXDPath(QString fname){
  QFile gh(fname);

  printf("%s\n",fname.toStdString().c_str());
  gh.open(QIODevice::ReadOnly);
  QString all =gh.readAll();
  QStringList lines = all.split(QRegExp("[\n\r]+"));
  all.clear();
    INP newAtom;
    newAtom.part=0;
  int i=0;
    extern molekul mol;
    extern int atmax;
    extern QList<INP> asymmUnit;
  if ((lines.size())&&(lines.at(0).contains("PATHFILE "))) {
    extern int smx;
    /*    while (!lines.at(i).contains("Gridpoints")) i++;
          QStringList tok = lines[i+1].split(' ',QString::SkipEmptyParts);
          breite= tok.at(0).toInt();
          hoehe=  tok.at(1).toInt();
          tiefe=  tok.at(2).toInt();
          bh = hoehe*breite;
          tok = lines[i+3].split(' ',QString::SkipEmptyParts);
          x_dim = Vector3(tok.at(0).toFloat()/breite,0,0);
          y_dim = Vector3(0,tok.at(1).toFloat()/hoehe,0);
          z_dim = Vector3(0,0,tok.at(2).toFloat()/tiefe);// */ //lets ignore that
    while (!lines.at(i).contains("Objects")) i++;
    {
      i++;
      smx=atmax=lines[i].toInt();
      i++;
      for (int j=0 ; j<atmax; j++){
        QStringList tok = lines[i+j].split(' ',QString::SkipEmptyParts);
        strncpy(newAtom.atomname,tok.at(0).toLatin1(),38);
        newAtom.kart.x=tok.at(1).toDouble();
        newAtom.kart.y=tok.at(2).toDouble();
        newAtom.kart.z=tok.at(3).toDouble();
        newAtom.u=Matrix(0.03, 0.0,0.0,0.0,0.03,0.0, 0.0,0.0,0.03);
        if (tok.contains("ATOM")){
          char *dv=NULL,dm[80];
          dv=strcpy(dm,newAtom.atomname);
          if (dv[0]=='X') dv+=3;
          strtok(dv,"(1234567890+- ");
          newAtom.OrdZahl=mol.Get_OZ(dv);
        } else{	
          if (tok.contains("CP")) {
            newAtom.OrdZahl=-2;
            if (tok.size()>5)newAtom.cptype=tok.at(5).section(QRegExp("[)(,]+"),2,2).toInt()+3;
          }
          else 
            newAtom.OrdZahl=-1;

        }
        asymmUnit.append(newAtom);
      }
    }

    /*  if (!smx) {
        smx=8;    
        for (int iz=0; iz <2;iz++)
        for (int iy=0; iy <2;iy++)
        for (int ix=0; ix <2;ix++) {
        Vector3 ppp =  ((ix*breite)*x_dim);
        ppp += ((iy*hoehe)*y_dim);
        ppp += ((iz*tiefe)*z_dim);
        newAtom.kart=V3(ppp.x,ppp.y,ppp.z);
        newAtom.OrdZahl=-1;
        strcpy(newAtom.atomname,"x");
        asymmUnit.append(newAtom);
        }
        } // */ 
  }
  while (!lines.at(i).contains("Curves")) {i++;}
  {
    i++;
    Bpth bpath;
    int ncurves=lines[i].toInt();
    int steps=0;
//    printf("number of curves %d\n",ncurves);
    i++;
    for (int j=0; j<ncurves; j++){
      bpath.pth.clear();
      QStringList tok = lines[i].split(' ',QString::SkipEmptyParts);
      bpath.start=tok.at(0).toInt();
      steps= tok.at(1).toInt();
    //  printf("j %d start %d steps %d i %d\n",j,bpath.start,steps,i);
//      qDebug()<<lines[i];
      V3 pos;
      int end= i+steps+1;
      for (int k=i+1; k<end; k++){
        tok = lines[k].split(' ',QString::SkipEmptyParts);
        pos.x=tok.at(0).toDouble();
        pos.y=tok.at(1).toDouble();
        pos.z=tok.at(2).toDouble();
        bpath.pth.append(pos);
      }
    wombats.append(bpath);
    i+=steps+1;
    }
  }
  gh.close();
/*  for (int k=0; k<wombats.size(); k++){
  printf("start %f %f %f %s\n"
      ,asymmUnit.at(wombats.at(k).start-1).kart.x 
      ,asymmUnit.at(wombats.at(k).start-1).kart.y 
      ,asymmUnit.at(wombats.at(k).start-1).kart.z
     ,asymmUnit.at(wombats.at(k).start-1).atomname);
  for (int m=0; m<wombats.at(k).pth.size();m++){
  printf("%f %f %f #%d\n"
      ,wombats.at(k).pth.at(m).x
      ,wombats.at(k).pth.at(m).y
      ,wombats.at(k).pth.at(m).z,m);
  }
  } //  */
//  printf("fine\n");
  {//xd_rho.cps   
    QString cpsName=fname;
    cpsName.chop(6);
    cpsName.append("xd_rho.cps");
    char cptp[10],_line[170]="Rho",dummystr[18];
    FILE *cps;
    int idxx=0,idx;
    if (NULL!=(cps=fopen(cpsName.toLocal8Bit(),"r"))){
      for (int aa=0; aa<asymmUnit.size(); aa++){
      if ((asymmUnit.at(aa).OrdZahl==-2)) {asymmUnit.removeAt(aa);--aa; }
      }
      while ((strstr(_line,"Rho"))&&(!feof(cps))) {fgets(_line,160,cps);idxx++;}
     idxx--;
    printf("idx!! %d\n",idxx);
      rewind(cps);
      for (int i=0;i<idxx;i++){
        fgets(_line,160,cps);
//1   (3,-1)   O(1) -C(1)      Rho     -0.799877   6.307969  13.264604           2.888
//2   (3,-1)   C(1) -N(1)      Rho      3.109743   4.772340   4.761444         2.26238      -19.10129      -16.07322       14.61587        0.59290  2  3
	if ((6==sscanf(_line,"%d %s %*19c %lf  %lf  %lf  %lf %*f %*f %*f %*f %*d %*d",&idx,cptp,
		      &newAtom.kart.x,  
		      &newAtom.kart.y,
		      &newAtom.kart.z,
		      &newAtom.peakHeight))||
            (6==sscanf(_line,"%d %s %*19c %lf  %lf  %lf  %lf",&idx,cptp,
		      &newAtom.kart.x,  
		      &newAtom.kart.y,
		      &newAtom.kart.z,
		      &newAtom.peakHeight))||
	    (5==(sscanf(_line,"%d %s %*19c %lf  %lf  %lf",&idx,cptp,
				&newAtom.kart.x,  
				&newAtom.kart.y,
				&newAtom.kart.z)))){
//	printf("line:%s",_line); 
	sprintf(dummystr,"CP%d",idx);
	strncpy(newAtom.atomname,dummystr,18);
	newAtom.OrdZahl=-2;
        mol.kart2frac(newAtom.kart,newAtom.frac);
        newAtom.cptype=QString(cptp).section(QRegExp("[)(,]+"),2,2).toInt()+3;
	asymmUnit.append(newAtom);
        }
      }
      fgets(_line,160,cps);
    }
    if (cps) fclose(cps);
  }
}


void molekul::atoms(CEnvironment atom,int proba){
  /*! Draws atoms as spheres or as ellipses cubes or icosahedrons.
   * @params atoms list of atoms to be drawn .
   * @params proba ellipsoid probability (currently 10 30 50 70 90 %).
   *
   * Molecule.dratom controls the wireframe style of the resulting atom .
   *
   * Molecule.tubifiedAtoms atom balls is drawn in bondstrength.
   *
   * Molecule.adp atom is drawn as a ellipsoid.
   *
   * Molecule.monoQrom Q-Peaks are drawn in Color Molecule.mQolor .
   * */
int myAdp=adp;
int myStyle=7;
int pminus=0;
int wire=0;
//GLfloat white[4]={0.2f, 0.2f, 0.3f, 0.0f};
GLfloat black[4]={0.0f, 0.0f, 0.0f, 1.0f};
for  (int i=0; i<atom.size();i++){
//if ((!dratom)&&(atom.at(i).hidden)) continue;
//if ((nopm1)&&(atom.at(i).sg)&&(atom.at(i).part<0))continue;
if ((dratom==2)&&(atom.at(i).part==0))continue;
if ((dratom==2)&&(atom.at(i).sg)&&(atom.at(i).part<0))continue;
//if ((dratom==2)&&(atom.at(i).hidden))continue;
//if ((dratom==5)&&(atom.at(i).hidden))continue;
int  nonPositiveDefinite=0;
    glPushMatrix();
    nonPositiveDefinite=0;
    glTranslated(atom.at(i).pos.x,atom.at(i).pos.y,atom.at(i).pos.z);
    double rad=(atom.at(i).an==-2)?0.5:qPeakRad;
    bool parthigh=false;
    if (dratom==5){
      wire=1;
      dratom=0;
    }
    if (dratom==2) {
      dratom=0;
      parthigh=true;
    }
    if (!dratom){
 //     printf("ph %d alpha %g tubes %d,myAdp %d %d\n",parthigh,Acol[atom.at(i).an][3],tubes,myAdp,((!myAdp)||((myStyle&ATOM_STYLE_SPHERE)&&(!(myStyle&ATOM_STYLE_SOLID)))));
     if (atom.at(i).an>-1) {
       myStyle=aStyle[atom.at(i).an];
       if (atom.at(i).Label.contains("(noADP)")) myStyle|=ATOM_STYLE_NOADP;
       glColor4d(Acol[atom.at(i).an][0],
               Acol[atom.at(i).an][1],
               Acol[atom.at(i).an][2],
              Acol[atom.at(i).an][3]);
       //printf("r%g g%g b%g a%g\n", Acol[atom.at(i).an][0],
         //             Acol[atom.at(i).an][1],
           //           Acol[atom.at(i).an][2],
             //        Acol[atom.at(i).an][3]);
       rad=arad[atom.at(i).an];

    glMaterialfv( GL_FRONT_AND_BACK, GL_EMISSION,black );
                  if ((atom.at(i).sg)&&(atom.at(i).part<0)){
                    glColor4d(Acol[atom.at(i).an][0],
                              Acol[atom.at(i).an][1],
                  1.0,
                  0.3);
            pminus=1;
                    myStyle|=ATOM_STYLE_NOADP;
          }
                myAdp=(myStyle&ATOM_STYLE_NOADP)?0:adp;
    }
     if (wire) {myStyle|=ATOM_STYLE_SPHERE;if (myStyle&ATOM_STYLE_SOLID)myStyle-=ATOM_STYLE_SOLID; }
     if (tubifiedAtoms){
       rad=bondStrength;
       if (atom.at(i).part==666) rad*=4.5;
       myAdp=0;
       nonPositiveDefinite=0;
     }
    if ((atom.at(i).an<0)||(atom.at(i).Label.startsWith('Q',Qt::CaseInsensitive))){
      glColor4d(1.0 ,0.7, 0.8 ,0.4);
      if (atom.at(i).an==-66) {
    rad*=2;
    glColor4d(0.6,0.3,0.1,0.3);
      }
      //if((atom.at(i).an==-1)&&(!monoQrom))
          Farbverlauf(atom.at(i).peakHeight, pmin, pmax);
      //if (monoQrom) glColor3d(mQolor[0],mQolor[1],mQolor.blueF());
//      if (!wire)
//    ikosa(rad);
    icosaeder(rad);

    }
    else {
      if (myAdp){
    V3 ev=V3(0,0,0);
    double *arr=jacobi2(atom.at(i).uc,ev);
    if ((ev.x>0)&&(ev.y>0)&&(ev.z>0)){
          nonPositiveDefinite=0;
    glRotated(Ato4d(arr));
    double psc=(parthigh)?1.32:1.0;
        if (atom.at(i).part==666) psc*=1.2;
    switch (proba ) {
        case 10 :{ glScaled(0.76*sqrt(ev.x)*psc,0.76*sqrt(ev.y)*psc,0.76*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 10% Wahrscheinlichkeit
        case 30 :{ glScaled(1.19*sqrt(ev.x)*psc,1.19*sqrt(ev.y)*psc,1.19*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 30% Wahrscheinlichkeit
        case 50 :{ glScaled(1.54*sqrt(ev.x)*psc,1.54*sqrt(ev.y)*psc,1.54*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 50% Wahrscheinlichkeit
        case 70 :{ glScaled(1.91*sqrt(ev.x)*psc,1.91*sqrt(ev.y)*psc,1.91*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 70% Wahrscheinlichkeit
        case 90 :{ glScaled(2.50*sqrt(ev.x)*psc,2.50*sqrt(ev.y)*psc,2.50*sqrt(ev.z)*psc);break;}   //Hauptachsen der Eliipsoide 90% Wahrscheinlichkeit
        default: ;
        }
      }else {nonPositiveDefinite=1;}
      }

       if (parthigh) {
     rad*=1.32;
         if (atom.at(i).part==666) rad*=1.2;
         glEnable(GL_BLEND);
         myStyle&=(ATOM_STYLE_SPHERE|ATOM_STYLE_NOADP);
     myStyle|=ATOM_STYLE_SPHERE;
       }
// */
      /*
#define ATOM_STYLE_WALLS 1
#define ATOM_STYLE_RINGS 2
#define ATOM_STYLE_SPHERE 4
#define ATOM_STYLE_SOLID 8
#define ATOM_STYLE_WHITERING 16
#define ATOM_STYLE_NOLABEL 32
*/
      if (atom.at(i).an>-1) {
/*
          glEnable(GL_BLEND);
          glDisable(GL_CULL_FACE);*/
        if (myAdp&&intern) {
          if (!nonPositiveDefinite) ellipse(myStyle);
          else cube(rad);
          }
        else if ((!myAdp)||((myStyle&ATOM_STYLE_SPHERE)&&(!(myStyle&ATOM_STYLE_SOLID)))){
          if (!myAdp) glScaled(rad,rad,rad);
          if (!nonPositiveDefinite) {
        if (wire)dratom =5;
        sphere(myAdp|pminus);

        //ellipse(myAdp);
      }
          else cube(rad);
        }
      }
      else
    //    ikosa(rad);
    icosaeder(rad);
    }
    }
    else{
     //   atom[i].hidden=0;
      sphere(0);
    }
    glEnable(GL_COLOR_MATERIAL);
    glMaterialfv( GL_FRONT_AND_BACK, GL_EMISSION,black );
    glPopMatrix();
    if (parthigh) dratom=2;
  }
}
void molekul::draw_polyeders(QList<INP> xdinp){
    //printf("draw_polyeders() %d\n",polyeders.size());

    if (polyeders.empty()) return;
    V3 nor;
    glEnable(GL_BLEND);
    glDisable(GL_CULL_FACE);
    glPushMatrix();
    glBegin(GL_TRIANGLES);
    for (int i=0; i<polyeders.size();i++){
         if (!allowedPolyeders.value(xdinp[polyeders.at(i).zi].OrdZahl,true)) continue;
        GLfloat colo[4]={
            Acol[xdinp[polyeders.at(i).zi].OrdZahl][0],
            Acol[xdinp[polyeders.at(i).zi].OrdZahl][1],
            Acol[xdinp[polyeders.at(i).zi].OrdZahl][2],
            Acol[xdinp[polyeders.at(i).zi].OrdZahl][3]}
            ;
        //colo[3]=0.7-(polyeders.at(i).volume/maxvolpol);
        nor=polyeders.at(i).norm;
        glNormal3d(nor.x,nor.y,nor.z);
        //glColor4f(0.0f,0.5f,0.0f,0.7f);
        if(polyShapColor)
            Farbverlauf((float)i,(float)0.0,(float)polyeders.size()-1.0f,0.5f);
         // Farbverlauf((float)polyeders.at(i).umfang,(float)maxvolpol-0.01,(float)maxvolpol+0.01,0.5);
     // printf("maxvolpol %g %g %g\n",maxvolpol,polyeders.at(i).volume,minvolpol);
        else glColor4fv(colo);
        if (polyeders.at(i).edge.size()==3){
        //    glColor4f(0.0f,0.0f,0.0f,0.0f);
            glVertex3d(xdinp[polyeders.at(i).edge.at(0)].kart.x,xdinp[polyeders.at(i).edge.at(0)].kart.y,xdinp[polyeders.at(i).edge.at(0)].kart.z);
            glVertex3d(xdinp[polyeders.at(i).edge.at(1)].kart.x,xdinp[polyeders.at(i).edge.at(1)].kart.y,xdinp[polyeders.at(i).edge.at(1)].kart.z);
            glVertex3d(xdinp[polyeders.at(i).edge.at(2)].kart.x,xdinp[polyeders.at(i).edge.at(2)].kart.y,xdinp[polyeders.at(i).edge.at(2)].kart.z);
        }
        else{
          for (int j=0; j<polyeders.at(i).edge.size();j++){
              int kk=polyeders.at(i).edge.size();
              int v1=polyeders.at(i).edge.at(j),v2=polyeders.at(i).edge.at((j+1)%kk);
              glVertex3d(polyeders.at(i).mid.x,polyeders.at(i).mid.y,polyeders.at(i).mid.z);
              glVertex3d(
                      xdinp[v1].kart.x,
                      xdinp[v1].kart.y,
                      xdinp[v1].kart.z);
              glVertex3d(
                      xdinp[v2].kart.x,
                      xdinp[v2].kart.y,
                      xdinp[v2].kart.z);
          }

        }
    }
    glEnd();/*
    glColor3f(0,0,0);
    glBegin(GL_LINES);
    for (int i=0; i<polyeders.size();i++){
    glVertex3d(polyeders.at(i).mid.x,polyeders.at(i).mid.y,polyeders.at(i).mid.z);
    glVertex3d(polyeders.at(i).mid.x+polyeders.at(i).norm.x,
               polyeders.at(i).mid.y+polyeders.at(i).norm.y,
               polyeders.at(i).mid.z+polyeders.at(i).norm.z);
    }
    glEnd();*/
    glPopMatrix();
    //glDisable(GL_CULL_FACE);
    glDisable(GL_BLEND);
}
void molekul::bonds(QList<INP> xdinp){

  //BINDUNGEN ab hier
  double gg;
  float wink;
  V3 vec;
  glDisable(GL_CULL_FACE);



  if (!knopf_made) make_knopf(xdinp);
  for (int k=0;k<bcnt;k++){
    if (!bondColorStyle) glColor4fv(Acol[xdinp[bd[k].a].OrdZahl]);
    vec=kreuzX(xdinp[bd[k].a].kart.x-xdinp[bd[k].e].kart.x,xdinp[bd[k].a].kart.y-xdinp[bd[k].e].kart.y,xdinp[bd[k].a].kart.z-xdinp[bd[k].e].kart.z,
	       0.0f,0.0f,1.0f);                 //Achse senkrecht zur Ebene Ursprung, Bindungs-Ende, Z-Achse 

    if (Norm(vec)==0.0) vec=V3(1.0,0.0,0.0);
    vec=Normalize(vec);
    glPushMatrix();	
    glTranslated (xdinp[bd[k].a].kart.x,xdinp[bd[k].a].kart.y,xdinp[bd[k].a].kart.z);//Anfangspunkt 	    
    wink=180+winkel(xdinp[bd[k].a].kart-xdinp[bd[k].e].kart,VZ); // Winkel zwischen Bindungs-Richtung und Z-Achse
    /*printf("Bond %d w%f %f %f %f  dis%f\n",k,wink,xdinp[bd[k].a].kart.x-xdinp[bd[k].e].kart.x,xdinp[bd[k].a].kart.y-xdinp[bd[k].e].kart.y,xdinp[bd[k].a].kart.z-xdinp[bd[k].e].kart.z,
	   //vec.x,vec.y,vec.z,
	   Norm(vec));*/

    glRotatef((float)wink,(float)vec.x,(float)vec.y,(float)vec.z); // drehen    
    GLUquadricObj *q = gluNewQuadric();
    gluQuadricNormals(q, GL_SMOOTH);   // ein Zylinder
    gluQuadricTexture(q,GL_TRUE);
    gg=100.0*sqrt( Distance(xdinp[bd[k].a].kart,xdinp[bd[k].e].kart));

    gluCylinder(q, bondStrength, bondStrength, (float)gg/(200.0f), 5*LOD, 1); 

    glPopMatrix();
  }	
  glEnable(GL_CULL_FACE);
}

int molekul::highlightResi(QList<INP> xdinp,int inv,GLfloat L,bool el){

  if ((inv<0)||(inv>=xdinp.size())){
    firstHL=0;
    lastHL=0;
   return 0;
  }

  QList<INP> xx; 
  firstHL=-1;
  lastHL=0;
  static int iit=21;
  char *tok,nme[80];
  int ri,rii=0,Ri;

  strcpy(nme,xdinp[inv].atomname);
  tok=strtok(nme,"@");

  tok=strtok(NULL,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_");

  ri=atoi(tok);
  for (int i=0;i<xdinp.size();i++){
    strcpy(nme,xdinp[i].atomname);
    tok=strtok(nme,"@");

    tok=strtok(NULL,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_");

    Ri=atoi(tok);
    if (ri==Ri){
      xx.append(xdinp[i]);
      rii++;
      firstHL=(firstHL==-1)?i:firstHL;
      lastHL=i;

    }

  }
  if (rii) {  
    static molekul m;
    if (iit) m.initDir();
    copyAcol(m.Acol,m.arad,m.aStyle);
    m.firstHL=firstHL;
    m.lastHL=lastHL;
    m.bonds_made=0;
    m.knopf_made=0;
    m.pmin=pmin;
    m.pmax=pmax;
    m.intern=1;
    m.adpwall=adpwall;
    iit=0;
    glPushMatrix();
    glScaled( L, L, L );
    m.adp=el;
    m.atoms(xx,proba);
    m.intern=0;
    glEnable(GL_BLEND);
    m.atoms(xx,proba);
    glDisable(GL_BLEND);
    m.bonds(xx);
    glPopMatrix(); 
  }
  firstHL=(firstHL==-1)?0:firstHL;

 return lastHL-firstHL;
}
void molekul::highlightInv(QList<INP> xdinp,int inv,GLfloat L){ 
  char ivname[80]="C1.5c[1.5c1.5c]1.5c[1.5c1.5c]1.5c[1.5c1.5c]",*tok; 
  strcpy(ivname,xdinp[inv].invariomname);
  int nextSphere[24],ci=0,fst=0,kla=0;
  if (!bonds_made) make_bonds(xdinp);
  if (!knopf_made) make_knopf(xdinp);

  {
  int al,ab;
  float ag;



  for (int i=0; i<Knopf[inv].lz-1;i++)
    for (int j=0; j<Knopf[inv].lz-1;j++)
      if ((xdinp[Knopf[inv].lig[j]].OrdZahl)&&(xdinp[Knopf[inv].lig[j+1]].OrdZahl)&&(Knopf[inv].bgrad[j]<Knopf[inv].bgrad[j+1])){
	al=Knopf[inv].lig[j];  
	ab=Knopf[inv].bnr[j];  
	ag=Knopf[inv].bgrad[j];
	Knopf[inv].lig[j]=  Knopf[inv].lig[j+1];    
	Knopf[inv].bnr[j]=  Knopf[inv].bnr[j+1];    
	Knopf[inv].bgrad[j]=Knopf[inv].bgrad[j+1];
	Knopf[inv].lig[j+1]=al;  
	Knopf[inv].bnr[j+1]=ab;  
	Knopf[inv].bgrad[j+1]=ag;
      }
  }



    kla=0;
  for (tok=strtok(ivname,"01235.");tok&&ci<40;tok=strtok(NULL,"01235.")){
    if (ci&&strchr(tok,'[')) {nextSphere[fst++]=1;kla=1;}
    else if (ci&&!kla) {nextSphere[fst++]=0;}
    if (strchr(tok,']')) {kla=0;}

    ci++;
  }



  int acnt=0;
  QList<INP> xx;

  xx.append(xdinp[inv]);
  acnt++;
  for (int i=0 ; i<Knopf[inv].lz;i++){



    xx.append(xdinp[Knopf[inv].lig[i]]);
    acnt++;
    if (nextSphere[i])
      for (int j=0 ; j<Knopf[Knopf[inv].lig[i]].lz;j++){
	if (strcmp(xdinp[inv].atomname,xdinp[Knopf[Knopf[inv].lig[i]].lig[j]].atomname)){



	  xx.append(xdinp[Knopf[Knopf[inv].lig[i]].lig[j]]);
	  acnt++;


	}
      }
  }
  static molekul m;
  glPushMatrix();
  glScaled( L, L, L );
  m.adp=0;
  m.atoms(xx,50);
  m.bonds(xx);
  glPopMatrix();
}
QString molekul::h_bonds(QList<INP> xdinp) { 
  
  glDisable(GL_CULL_FACE);
  if (HAMax<0.01)return "";
  glEnable(GL_ALPHA_TEST);
  glBindTexture(GL_TEXTURE_2D, hbtex);
  glEnable(GL_TEXTURE_2D);
  QString hbonds;
/*  FILE *out=fopen("Hbonds.txt","w");*/

  double gg=0,kk=0,ll=0;
  float wink,hb_wink;
  V3 vec;
  int Hyd,Acc,Don=0;//Wasserstoff Akzeptor und Donator
  if (!bonds_made) make_bonds(xdinp);
  if (!knopf_made) make_knopf(xdinp); 
  
  /*printf("nachm Knopf: %s 1st neighbors %d 2nd neighbors %d\n%d %d %d\n",
	 xdinp[xdinp.size()/3].atomname,
	 xdinp[xdinp.size()/3].firstNeighbors,
	 xdinp[xdinp.size()/3].secondNeighbors,knopf_made,xdinp.size(),bcnt);
  */
//  if (out) fprintf(out,
hbonds.append("<h2>Hydrogen Bonds</h2><table border=1><tr><th>Donator---Hydrogen...Acceptor</th><th>Don--Hyd [&Aring;]</th><th> Hyd--Acc [&Aring;]</th><th>Don--Acc [&Aring;]</th><th>D--H-----A </th></tr>");
  for (int i=0;i<xdinp.size();i++) {
    for (int j=i+1;j<xdinp.size();j++) {

      if (((xdinp[i].OrdZahl==0)&&(ElNeg[xdinp[j].OrdZahl]>240))||
	  ((xdinp[j].OrdZahl==0)&&(ElNeg[xdinp[i].OrdZahl]>240))) {      
	Hyd=(xdinp[i].OrdZahl==0)?i:j;
	Acc=(xdinp[i].OrdZahl==0)?j:i;
	Don=(Knopf[Hyd].lz)?Knopf[Hyd].lig[0]:0;	

	gg=sqrt( Distance(xdinp[i].kart,xdinp[j].kart));
	
	if (gg<=HAMax){
	  hb_wink=winkel(xdinp[Acc].kart-xdinp[Hyd].kart, xdinp[Don].kart-xdinp[Hyd].kart);	  
          if ((gg>=1.3)&&(fabs(hb_wink)>HAWink)&&(strstr(xdinp[i].atomname,"dum")==NULL)&&(strstr(xdinp[j].atomname,"dum")==NULL)) {//wenn AbstandRichtig
	    ll=sqrt(Distance(xdinp[Acc].kart,xdinp[Don].kart));
	    kk=sqrt(Distance(xdinp[Don].kart,xdinp[Hyd].kart));
	    hbonds.append(QString("<tr><td>%1---%2...%3</td><td>%4</td><td>%5</td><td>%6</td><td>%7&deg;</td></tr>").arg(xdinp[Don].atomname).arg(xdinp[Hyd].atomname).arg(xdinp[Acc].atomname).arg(kk).arg(gg).arg(ll).arg(hb_wink));
	    glPushMatrix();
	    glTranslated (xdinp[j].kart.x,xdinp[j].kart.y,xdinp[j].kart.z);//z 	    
	    vec=kreuzX(xdinp[i].kart.x-xdinp[j].kart.x,xdinp[i].kart.y-xdinp[j].kart.y,xdinp[i].kart.z-xdinp[j].kart.z,
		       0.0f,0.0f,1.0f); 

	    wink=winkel(xdinp[i].kart-xdinp[j].kart,VZ);               // Winkel zwischen Bindungs-Richtung und Z-Achse	    
	    glRotatef(wink,vec.x,vec.y,vec.z); // drehen
	    GLUquadricObj *q = gluNewQuadric();
	    gluQuadricNormals(q, GL_SMOOTH);   // ein Zylinder
	    //if (!adp) 
	    if (gg>2.0) glColor4f(1,0.6,0,1);	else glColor4f(1,1,0,1);	
	    gluQuadricTexture(q,GL_TRUE);
	    gluCylinder(q,bondStrength*1.05 , bondStrength*1.05, (float)gg, 5*LOD, 1);	    
	    glPopMatrix(); 
	  }
	}
      }
    }
  }

  glDisable(GL_ALPHA_TEST);

  glDisable(GL_TEXTURE_2D);

  

  
   glEnable(   GL_CULL_FACE);
  if (hbonds.contains("deg;")) hbonds.append("</table><br>");
  else hbonds.clear();
 return hbonds;
} 

void molekul::cbonds(QList<INP> xdinp){
  glDisable(GL_CULL_FACE);
  glEnable(GL_ALPHA_TEST);
  glBindTexture(GL_TEXTURE_2D, hbtex);
  glEnable(GL_TEXTURE_2D);
  float wink;
  V3 vec;
  for (int k=0; k<cBonds.size();k++){
    int i=cBonds.at(k).a;
    int j=cBonds.at(k).e;
    float gg=sqrt( Distance(xdinp[i].kart,xdinp[j].kart));
    glPushMatrix();
    glTranslated (xdinp[j].kart.x,xdinp[j].kart.y,xdinp[j].kart.z);//z 	    
    vec=kreuzX(xdinp[i].kart.x-xdinp[j].kart.x,xdinp[i].kart.y-xdinp[j].kart.y,xdinp[i].kart.z-xdinp[j].kart.z,
		    0.0f,0.0f,1.0f); 

    wink=winkel(xdinp[i].kart-xdinp[j].kart,VZ);               // Winkel zwischen Bindungs-Richtung und Z-Achse	    

    glRotatef(wink,vec.x,vec.y,vec.z); // drehen
    GLUquadricObj *q = gluNewQuadric();
    gluQuadricNormals(q, GL_SMOOTH);   // ein Zylinder
    //if (!adp) 
    glColor4f(1,0,1,1);	
    gluQuadricTexture(q,GL_TRUE);
    gluCylinder(q,bondStrength*1.05 , bondStrength*1.05, (float)gg, 5*LOD, 1);	    
    glPopMatrix(); 
  }
  glDisable(GL_ALPHA_TEST);
  glDisable(GL_TEXTURE_2D);
  glEnable(   GL_CULL_FACE);
}

/*
void molekul::labels( QList<INP> xdinp)
{
  //LABELS
  glDisable( GL_LIGHTING );
  glDisable( GL_DEPTH_TEST ); 

  glPushMatrix();{ 
    for (int j=0;j<xdinp.size();j++){

    } 
    
    }glPopMatrix(); 
  glEnable( GL_LIGHTING ); 
  glEnable( GL_DEPTH_TEST );  
}
*/
/*
V3 *  molekul::smoothPoints(V3 *vListe, int N){
  //berecnet aus N puntkten N-1 neue Punkte um Kurven etwas abzurunden
  V3 v1,v2,*newP,ppP,laP=V3(0,0,0);
  int ende=0,stopped=1;

  int newN,ni,ai;
  ppP.x=0;
  ppP.y=0;
  ppP.z=0;
  for (int i=1; i<N-1; i++){
    if (((vListe[i-1].x+vListe[i-1].y+vListe[i-1].z)==0.0)&&
	((vListe[i+1].x+vListe[i+1].y+vListe[i+1].z)==0.0)){
	  vListe[i].x=0.0;
	  vListe[i].y=0.0;
	  vListe[i].z=0.0;
    }    
  }

  newP=(V3*)malloc(sizeof(V3)*(N-2));

  while (ende<N-2){ 
    for (int i=ende+1; i<N-1; i++){
      if (((vListe[i-1].x+vListe[i-1].y+vListe[i-1].z)==0.0)||
	  ((vListe[i].x+vListe[i].y+vListe[i].z)==0.0)||
	  ((vListe[i+1].x+vListe[i+1].y+vListe[i+1].z)==0.0)) {

	if ((vListe[i-1].x+vListe[i-1].y+vListe[i-1].z)==0) {
	  newP[i-1].x=0.0;
	  newP[i-1].y=0.0;
	  newP[i-1].z=0.0;
	} else newP[i-1]=laP;

	ende=i;
	stopped=1;
	break; 
      }
      if(i) v1=vListe[i]-vListe[i-1];
      v2=vListe[i+1]-vListe[i];
      newP[i-1]=(!stopped)?0.5*(ppP+vListe[i]-1/7.0*v2-1/7.0*v1):
	vListe[i]-1/7.0*v2-1/7.0*v1;    
      newP[i-1].rc=vListe[i].rc;
      ppP=vListe[i]+1/7.0*v1+1/7.0*v2;

      laP=vListe[i+1];
      ende=i;
      stopped=0;
    }

  }

  newN=2*N-2;
  ni=0;ai=0;

  if (NULL==(nL=(V3*)malloc(sizeof(V3)*newN))) {perror("sch...\n");exit(0);}

  for (int i=0; i<newN; i++){


    nL[i]=((i)%2)?newP[ni++]:vListe[ai++];
  }
  nL[newN-1]= vListe[N-1];



  free(newP);
  nListe=newN;
  free(vListe);
  vListe=NULL;
 return nL;
}
*/
void molekul::Farbverlauf (GLfloat wrt,GLfloat min,GLfloat max,GLfloat alpha){
  GLclampd ff[4];
  int lauf=0;
  const GLclampd farbe[6][4]={{1.0,0.0,0.0,1.0},
			{1.0,1.0,0.0,1.0},
			{0.0,1.0,0.0,1.0},
			{0.0,1.0,1.0,1.0},
			{0.0,0.0,1.0,1.0},
			{1.0,0.0,1.0,1.0}};
  if ((max-min)<0.0001) max+=0.0001;
  GLfloat nwrt=(wrt-min)/(max-min);
  nwrt=(nwrt>=1.0)?0.99999:nwrt;
  nwrt=(nwrt<=0.0)?0.00001:nwrt;
  lauf=(int (nwrt/0.2));
  nwrt-=(0.2*lauf);
  nwrt/=(0.2);
  


  ff[0]=(1.0-nwrt)*farbe[lauf][0]+farbe[lauf+1][0]*nwrt;
  ff[1]=(1.0-nwrt)*farbe[lauf][1]+farbe[lauf+1][1]*nwrt;
  ff[2]=(1.0-nwrt)*farbe[lauf][2]+farbe[lauf+1][2]*nwrt;
  ff[3]=alpha;

  glColor4dv(ff);


 return;
}

/*
void molekul::drawSline(V3 *vL,int N){


  V3 nv1,v1,v2,lnv;
  GLfloat nv2;
  int arc=-55;
  glColor3f(0.9f,0.3f,0.5f);
  //  
  glDisable(GL_LIGHTING);
  glLineWidth(1);
  glLightModeli(  GL_LIGHT_MODEL_TWO_SIDE, 1 );
  glBegin(GL_LINE_STRIP);
  for (int i=0;i<N;i++){

    if ((arc!=vL[i].rc)||((vL[i].x+vL[i].y+vL[i].z)==0.0)) {
      glEnd();
      switch (vL[i].rc){
      case 1:glEnable(GL_LIGHTING);glBegin(GL_TRIANGLE_STRIP);break;
      default :glDisable(GL_LIGHTING);glBegin(GL_LINE_STRIP);break;
      }
      if(fvl)Farbverlauf((float)i-1,0,N);
      if (i&&(vL[i-1].x+vL[i-1].y+vL[i-1].z)!=0.0) glVertex3f(vL[i-1].x,vL[i-1].y,vL[i-1].z);
      arc=vL[i].rc;
    }
    if ((vL[i].x+vL[i].y+vL[i].z)==0.0) 
      continue;


    if ((i>1)&&(i<N-2)) {
      nv1=(((vL[i-2]-vL[i])+(vL[i-1]-vL[i]))%((vL[i+1]-vL[i])+(vL[i+2]-vL[i])));
      nv2=Norm(nv1);
      nv1=Normalize(nv1);
      if (nv2<0.005) nv1*=0.1; 
      
      if (vL[i].rc!=1)nv1*=0.001;
      lnv=(vL[i-1]-vL[i])
	+ (vL[i+1]-vL[i])
	+ (vL[i-2]-vL[i])
	+ (vL[i+2]-vL[i]);
      lnv=Normalize(lnv);
      lnv*=-1.0;
      v1=vL[i]+0.3*nv1;
      v2=vL[i]-0.3*nv1;
      / *
      V3 dumv=lnv+v1;
      glEnd();
      glDisable(GL_LIGHTING);
      glBegin(GL_LINES);
      if (vL[i].rc==1) glColor3f(1.0,1.0,1.0); else glColor3f(1.0,1.0,0.0);
      glVertex3f(v1.x,v1.y,v1.z);
      glColor3f(0.0,0.0,1.0);
      glVertex3f(dumv.x,dumv.y,dumv.z);
      glEnd();
      switch (vL[i].rc){
      case 1:glEnable(GL_LIGHTING);glBegin(GL_TRIANGLE_STRIP);break;
      default :glDisable(GL_LIGHTING);glBegin(GL_LINE_STRIP);break;
      }
      * /
    if(fvl)Farbverlauf((float)i,0,N);
      glNormal3f(lnv.x,lnv.y,lnv.z);
      glVertex3f(v1.x,v1.y,v1.z);

      glVertex3f(v2.x,v2.y,v2.z);
    }

    glColor3f(0.2f,0.3f,0.5f);
  }
  glEnd();
  glLineWidth(1);

  glEnable(GL_LIGHTING);
}
V3* molekul::addToList(V3 *vL,QList<INP> xdinp,int atom,int N,int rc){
  vL=(V3*)realloc(vL,sizeof(V3)*(N+1));
  vL[N].x=xdinp[atom].kart.x;
  vL[N].y=xdinp[atom].kart.y;
  vL[N].z=xdinp[atom].kart.z;
  vL[N].rc=rc;


 return vL;
}
void molekul::findChains(QList<INP> xdinp){


  if (!bonds_made) make_bonds(xdinp);


  if (!knopf_made) make_knopf(xdinp);




  QString rama;
  int lastI=-100,lastJ=0,j,k,l=0,h=0;  
  int rc=0;;
  char match[25],match1[25],match2[25];
  for (int i=0; i<xdinp.size(); i++){
    if (xdinp[i].OrdZahl==6) {//N


      if ((Knopf[i].lz)&&(xdinp[Knopf[i].lig[0]].OrdZahl==5)) h=Knopf[i].lig[0];
      for (int n=0;n<Knopf[i].lz;n++){


	j=Knopf[i].lig[n];
	


	if ((xdinp[j].OrdZahl==5))//C 	
	  for (int m=0;m<Knopf[j].lz;m++){


	    k=Knopf[j].lig[m]; 
	    strcpy(match,"");
	    for (int o=0;o<Knopf[k].lz;o++){
	      match[o]=((char)xdinp[Knopf[k].lig[o]].OrdZahl+64);
	      match[o+1]='\0';
	      if ((xdinp[k].OrdZahl==5)&&(xdinp[Knopf[k].lig[o]].OrdZahl==6)) l=Knopf[k].lig[o]; 
	    }

	    for (int w=0;w<Knopf[i].lz;w++){
	      match1[w]=((char)xdinp[Knopf[i].lig[w]].OrdZahl+64);
	      match1[w+1]='\0';
	    }
	    for (int v=0;v<Knopf[j].lz;v++){
	      match2[v]=((char)xdinp[Knopf[j].lig[v]].OrdZahl+64);
	      match2[v+1]='\0';
	    }
	      //if (xdinp[Knopf[k].lig[o]].OrdZahl==7)



	    if ((strchr(xdinp[i].atomname,'G'))&&
		(!strstr(xdinp[i].atomname,"Glu"))&&
		(!strstr(xdinp[i].atomname,"Gln"))&&
		(!strstr(xdinp[i].atomname,"Gly"))) lastI=i;
	    if ((strstr(match1,"@@"))&&(strstr(match,"EGG")))lastI=i;
	    if ((lastI!=i)&&(strchr(match,'G'))&&(!strchr(match1,'G'))&&(!strchr(match2,'G'))){
	      lastI=i;
	      double ll=0;
	      if (nListe) ll=sqrt( Distance(vL[nListe-1],xdinp[j].kart));
		if ((nListe)&&((3.9<ll)||(3.7>ll))){

		  vL=(V3*)realloc(vL,sizeof(V3)*(++nListe)); 
		  vL[nListe-1].x=0; 
		  vL[nListe-1].y=0; 
		  vL[nListe-1].z=0; 
		} 
        / *
		l2=sqrt( pow((double)xdinp[i].kart[0]-xdinp[l].kart[0],2.0)+//Ketten-Ende
			 pow((double)xdinp[i].kart[1]-xdinp[l].kart[1],2.0)+
			 pow((double)xdinp[i].kart[2]-xdinp[l].kart[2],2.0));
		mini=(mini<l2)?mini:l2;
		maxi=(maxi>l2)?maxi:l2;
        * /;
		double phi=0,psi=0; 
                rama.append(QString("%1-%2-%3-%4-%5  phi=%6 psi=%7 %8\n") 
				 .arg(xdinp[h].atomname)
				 .arg(xdinp[i].atomname)
				 .arg(xdinp[j].atomname)
				 .arg(xdinp[k].atomname)
				 .arg(xdinp[l].atomname)
				 .arg(phi=dieder(xdinp[i].kart-xdinp[h].kart, xdinp[i].kart-xdinp[k].kart, xdinp[j].kart-xdinp[k].kart),8,'f',5)	  
				 .arg(psi=dieder(xdinp[j].kart-xdinp[i].kart, xdinp[j].kart-xdinp[k].kart, xdinp[k].kart-xdinp[l].kart),8,'f',5) 
				 .arg(j));	  
                if ((phi<-30)&&(phi>-90)&&(psi<0)&&(psi>-60)) rc=1;
                else if ((phi<-20)&&(phi>-170)&&(psi<170)&&(psi>0)) rc=2;
                else rc=0;


		lastJ=j;
		while (nListe<3) vL=addToList(vL,xdinp,j,nListe++,rc);			    
		vL=addToList(vL,xdinp,j,nListe++,rc);			    
	      }
	    }
	  
      }
    }
  }
  if(nListe) {vL=addToList(vL,xdinp,lastJ,nListe++,rc);vL=addToList(vL,xdinp,lastJ,nListe++,rc);}


  if (!rama.isEmpty()){
    QFile ramaf("ramachandran.txt");
    if (ramaf.open(QIODevice::WriteOnly)){
      ramaf.write(rama.toUtf8());
      ramaf.close();
    }
  }

}
*/
void molekul::frac2kart (V3 x, V3 & y){
//x ist fraktionell, y wird kartesisch
  
  y.x = x.x * zelle.f2c.m11 + x.y * zelle.f2c.m12 + x.z * zelle.f2c.m13;
  y.y = x.x * zelle.f2c.m21 + x.y * zelle.f2c.m22 + x.z * zelle.f2c.m23;
  y.z = x.x * zelle.f2c.m31 + x.y * zelle.f2c.m32 + x.z * zelle.f2c.m33;
  
}
void molekul::kart2frac (V3 x, V3 & y){
//x ist kartesisch, y wird fraktionell


  double phi;

  const double g2r=180.0/M_PI;
  Matrix u;   /*Cholesky decomposition of theReal space Metric tensor
              Wird fÃÂ¼r die Umrechnung von fraktionellen in kartesischen Korrdinaten benÃÂ¶tigt.*/

  phi=sqrt(1-pow(cos(zelle.al/g2r),2.0)-pow(cos(zelle.be/g2r),2.0)-pow(cos(zelle.ga/g2r),2.0)+2.0*cos(zelle.al/g2r)*cos(zelle.be/g2r)*cos(zelle.ga/g2r));
  y.x =0.0 ;
  y.y =0.0 ;
  y.z =0.0;
  u.m11 = 1.0/zelle.a;
  u.m21 = 0.0;
  u.m31 = 0.0;
  u.m12 = -1.0/(zelle.a * tan(zelle.ga/g2r));
  u.m22 = 1.0/(zelle.b * sin(zelle.ga/g2r));
  u.m32 = 0.0;
  u.m13 = (cos(zelle.al/g2r)*cos(zelle.ga/g2r)-cos(zelle.be/g2r))/(zelle.a*phi*sin(zelle.ga/g2r));
  u.m23 = (cos(zelle.be/g2r)*cos(zelle.ga/g2r)-cos(zelle.al/g2r))/(zelle.b*phi*sin(zelle.ga/g2r));
  u.m33 = sin(zelle.ga/g2r)/(zelle.c*phi);
      // Wird jetzt hier genauso wie in int Tab B S.345 gerechnet (M^-1^).
  y.x = x.x * u.m11 + x.y * u.m12 + x.z * u.m13;
  y.y = x.x * u.m21 + x.y * u.m22 + x.z * u.m23;
  y.z = x.x * u.m31 + x.y * u.m32 + x.z * u.m33;
}
void molekul::delBlanks(char *in){
  char s[82];
  int j=0;
  for (unsigned int i=0;i<=strlen(in);i++){
    if (in[i]!=' ') {s[j++]=in[i];}
  }
  in=strcpy(in,s);
}

void molekul::copyAcol(GLfloat _Acol[108][4],GLfloat _arad[108],int _aStyle[108]){//hier gibts was zu tun!
  for (int i=0; i<107;i++){
    _Acol[i][0]= Acol[i][0];
    _Acol[i][1]= Acol[i][1];
    _Acol[i][2]= Acol[i][2];
    _Acol[i][3]= Acol[i][3];
    _arad[i]=arad[i];
    _aStyle[i]=aStyle[i];
  }
}
bool molekul::decodeSymmCard(const QString symmCard){

  QString sc=symmCard.toUpper().remove("SYMM").trimmed();  
  sc.remove("'");
  sc.remove(" ");

  QStringList axe=sc.split(",");
  QStringList bruch;
  if (axe.size()<3) return false;
  double sx[3],sy[3],sz[3],t[3];
  for (int i=0; i<3; i++){
    sx[i]=0;sy[i]=0;sz[i]=0;t[i]=0;
    if (axe.at(i).contains("-X")) {sx[i]=-1.0;axe[i].remove("-X");}
    else if (axe.at(i).contains("+X")) {sx[i]=1.0;axe[i].remove("+X");}
    else if (axe.at(i).contains("X")) {sx[i]=1.0;axe[i].remove("X");}
    if (axe.at(i).contains("-Y")) {sy[i]=-1.0;axe[i].remove("-Y");}
    else if (axe.at(i).contains("+Y")) {sy[i]=1.0;axe[i].remove("+Y");}
    else if (axe.at(i).contains("Y")) {sy[i]=1.0;axe[i].remove("Y");}
    if (axe.at(i).contains("-Z")) {sz[i]=-1.0;axe[i].remove("-Z");}
    else if (axe.at(i).contains("+Z")) {sz[i]=1.0;axe[i].remove("+Z");}
    else if (axe.at(i).contains("Z")) {sz[i]=1.0;axe[i].remove("Z");}
    if (axe.at(i).endsWith("+")) axe[i].remove("+");
    if (axe.at(i).contains("/")) {
      bruch=axe.at(i).split("/");
      if (bruch.size()==2) t[i]=bruch.at(0).toDouble() / bruch.at(1).toDouble();  
    }
    else if (!axe.at(i).isEmpty()) t[i]=axe.at(i).toDouble();
  }
  Matrix sm = Matrix(
      sx[0],sy[0],sz[0],	  
      sx[1],sy[1],sz[1],  
      sx[2],sy[2],sz[2]);
  if (axe.size()==4){
    V3 x4sym;
    double x4,x4tr;
    x4sym.x=0;x4sym.y=0;x4sym.z=0;x4tr=0;
    if (axe.at(3).contains("-X")) {x4sym.x=-1.0;axe[3].remove("-X");}
    else if (axe.at(3).contains("X")) {x4sym.x=1.0;axe[3].remove("X");}
    if (axe.at(3).contains("-Y")) {x4sym.y=-1.0;axe[3].remove("-Y");}
    else if (axe.at(3).contains("Y")) {x4sym.y=1.0;axe[3].remove("Y");}
    if (axe.at(3).contains("-Z")) {x4sym.z=-1.0;axe[3].remove("-Z");}
    else if (axe.at(3).contains("Z")) {x4sym.z=1.0;axe[3].remove("Z");}
    if (axe.at(3).contains("-R")) {x4=-1.0;axe[3].remove("-R");}
    else if (axe.at(3).contains("R")) {x4=1.0;axe[3].remove("R");}
    if (axe.at(3).endsWith("+")) axe[3].remove("+");
    if (axe.at(3).contains("/")) {
      bruch=axe.at(3).split("/");
      if (bruch.size()==2) x4tr=bruch.at(0).toDouble() / bruch.at(1).toDouble();  
    }
    else if (!axe.at(3).isEmpty()) x4tr=axe.at(3).toDouble();
  
  zelle.x4.append(x4);
  zelle.x4tr.append(x4tr);
  zelle.x4sym.append(x4sym);
  printf("sm\n%2g %2g %2g %2g, %g\n%2g %2g %2g %2g, %g\n%2g %2g %2g %2g, %g\n%2g %2g %2g %2g, %g\n\n", sm.m11,sm.m21,sm.m31,0.,t[0],sm.m12,sm.m22,sm.m32,0.,t[1],sm.m13,sm.m23,sm.m33,0.,t[2],x4sym.x,x4sym.y,x4sym.z,x4,x4tr);
//  printf("[%d]%s%s%s%s%s%f\n",zelle.x4.size(),(x4sym.x==0.0)?"":(x4sym.x==1.0)?"x1":"-x1", (x4sym.y==0.0)?"":(x4sym.y==1.0)?"+x2":"-x2", (x4sym.z==0.0)?"":(x4sym.z==1.0)?"+x3":"-x3", (x4==1.0)?"+x4":"-x4", (x4tr<0)?"":"+",x4tr); 
  }
  zelle.symmops.append(sm);
  zelle.trans.append(V3(t[0],t[1],t[2]));
//printf("\n%g %g %g %g\n%g %g %g %g\n%g %g %g %g\n\n", sx[0],sy[0],sz[0],t[0],sx[1],sy[1],sz[1],t[1],  sx[2],sy[2],sz[2],t[2]);
//printf("Sm\n%g %g %g \n%g %g %g \n%g %g %g \n\n", sm.m11,sm.m21,sm.m31,sm.m12,sm.m22,sm.m32,sm.m13,sm.m23,sm.m33);


  return true;
}
QString molekul::encodeSymm(int s){
    QString erg="  ";
    Matrix m;
    V3 t;
    m=zelle.symmops.at(s);
    QString symstrX,symstrY,symstrZ;
    if (m.m11==1) symstrX.append("+x");
    if (m.m11==-1) symstrX.append("-x");
    if (m.m12==1) symstrX.append("+y");
    if (m.m12==-1) symstrX.append("-y");
    if (m.m13==1) symstrX.append("+z");
    if (m.m13==-1) symstrX.append("-z");

    if (m.m21==1) symstrY.append("+x");
    if (m.m21==-1) symstrY.append("-x");
    if (m.m22==1) symstrY.append("+y");
    if (m.m22==-1) symstrY.append("-y");
    if (m.m23==1) symstrY.append("+z");
    if (m.m23==-1) symstrY.append("-z");

    if (m.m31==1) symstrZ.append("+x");
    if (m.m31==-1) symstrZ.append("-x");
    if (m.m32==1) symstrZ.append("+y");
    if (m.m32==-1) symstrZ.append("-y");
    if (m.m33==1) symstrZ.append("+z");
    if (m.m33==-1) symstrZ.append("-z");
    t=zelle.trans.at(s);
    V3 zaehler,nenner;
    double egal;
    for (int g=1;g<5; g++){
        nenner.x=(t.x<0)?-g:g;;
        zaehler.x=(int)((t.x)*g);
        if (fabs(modf(t.x*g,&egal))<0.05) break;
    }
    for (int g=1;g<5; g++){
        nenner.y=(t.y<0)?-g:g;
        zaehler.y=(int)((t.y)*g);
        if (fabs(modf(t.y*g,&egal))<0.05) break;
    }
    for (int g=1;g<5; g++){
        nenner.z=(t.z<0)?-g:g;
        zaehler.z=(int)((t.z)*g);
        if (fabs(modf(t.z*g,&egal))<0.05) break;
    }
    erg.append(QString("%1/%2%3, %4/%5%6, %7/%8%9 \n")
               .arg(zaehler.x)
               .arg(nenner.x)
               .arg(symstrX)
               .arg(zaehler.y)
               .arg(nenner.y)
               .arg(symstrY)
               .arg(zaehler.z)
               .arg(nenner.z)
               .arg(symstrZ));

    erg.remove(QRegExp("0/\\d"));
    erg.replace(" +","  ");
    erg.replace("1/1","1");
    erg.replace("2/1","2");
    erg.replace("3/1","3");
    erg.replace("4/1","4");
    erg.replace("5/1","5");
    return erg;
}


void molekul::bonds(Connection bond){
 /*! @params bond list of bonds to be drawn
  * draws bonds as cylinders with radius Molecule.bondStrength .
  * Bonds start and stop at the atom surface.
  */
    //printf("Bonds %d %d\n",bond.size(),dratom);
//  GLfloat white[4]={0.2, 0.2, 0.3, 0.0};
  GLfloat black[4]={0.0, 0.0, 0.0, 1.0};
  glDisable(GL_BLEND);
  glEnable(GL_ALPHA_TEST);
  glBindTexture(GL_TEXTURE_2D, hbtex);
  //printf("Doing Bonds adp=%d proba=%d tubes%d\n",adp,proba,tubes);
  V3 vec,bondir;
  double kurz=0,ara1,ara2;
  double wink;
  bool parthigh=false;
  double psc=1.0;
  if (dratom==2) {
    dratom=0;
    parthigh=true;
    psc=1.32;
    glEnable(GL_BLEND);
    glDisable(GL_ALPHA_TEST);
//    glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
  }
  for (int i=0; i<bond.size();i++){
      if ((parthigh)&&((bond.at(i).ato1->part==0)||(bond.at(i).ato2->part==0))) continue;
      if ((parthigh)&&(((bond.at(i).ato1->part<0)&&(bond.at(i).ato1->sg))||((bond.at(i).ato2->part<0)&&(bond.at(i).ato2->sg)))) continue;
      //if ((nopm1)&&(bond.at(i).ato1->sg)&&(bond.at(i).ato1->part<0))continue;
      //if ((nopm1)&&(bond.at(i).ato2->sg)&&(bond.at(i).ato2->part<0))continue;
      glDisable(GL_TEXTURE_2D);
    glColor4d(0.5,0.3,0.3,1.0);
    if (adp) {
      V3 hin=Normalize(bond.at(i).ato2->pos-bond.at(i).ato1->pos);
      double r=1;
      switch (proba){
          case 10:r=0.76;break;
          case 30:r=1.19;break;
          case 50:r=1.54;break;
          case 70:r=1.91;break;
          case 90:r=2.50;break;
      }
      ara1=sqrt((hin*bond.at(i).ato1->uc)*hin);
      ara1*=r;
      ara2=sqrt((hin*bond.at(i).ato2->uc)*hin);
      ara2*=r;
      //printf("%s-%s %f %f %d %f\n",bond.at(i).ato1->Label.toStdString().c_str(),bond.at(i).ato2->Label.toStdString().c_str(),ara1, ara2, proba,r);
    }
    else{
      ara1=arad[bond.at(i).ato1->an];
      ara2=arad[bond.at(i).ato2->an];
    }
    if (bond.at(i).ato1->Label.contains("noADP"))ara1=arad[bond.at(i).ato1->an];
    if (bond.at(i).ato2->Label.contains("noADP"))ara2=arad[bond.at(i).ato2->an];
    if (aStyle[bond.at(i).ato1->an]&ATOM_STYLE_NOADP) ara1=arad[bond.at(i).ato1->an];
    if (aStyle[bond.at(i).ato2->an]&ATOM_STYLE_NOADP) ara2=arad[bond.at(i).ato2->an];

    if (((bond.at(i).ato1->sg)&&(bond.at(i).ato1->part<0))) ara1=arad[bond.at(i).ato1->an];
    if (((bond.at(i).ato2->sg)&&(bond.at(i).ato2->part<0))) ara2=arad[bond.at(i).ato2->an];
    if (tubifiedAtoms) ara1=ara2=bondStrength;
    if (bond.at(i).ato2->an>-1) {
        glColor4d(Acol[bond.at(i).ato2->an][0],
                  Acol[bond.at(i).ato2->an][1],
                  Acol[bond.at(i).ato2->an][2],
                  Acol[bond.at(i).ato2->an][3]);

    }

    ara1=qMax(ara1,bondStrength);
    ara2=qMax(ara2,bondStrength);

   /* if ((highlightEquivalents)&&(bond.at(i).ato2->sg|bond.at(i).ato1->sg))
        glMaterialfv( GL_FRONT_AND_BACK, GL_EMISSION,white );
    else */
        glMaterialfv( GL_FRONT_AND_BACK, GL_EMISSION,black );
    if ((bond.at(i).ato2->sg|bond.at(i).ato1->sg)&&((bond.at(i).ato2->part<0)||(bond.at(i).ato1->part<0))){
      //		    glMaterialfv( GL_FRONT_AND_BACK, GL_EMISSION,blue );
      glColor4d(Acol[bond.at(i).ato2->an][0],
                Acol[bond.at(i).ato2->an][1],
        1.0,
        0.3);
      glEnable(GL_BLEND);
    }
    vec.x=(bond.at(i).ato2->pos.y-bond.at(i).ato1->pos.y);
    vec.y=(bond.at(i).ato1->pos.x-bond.at(i).ato2->pos.x);
    vec.z=0;
    if (Norm(vec)) vec=Normalize(vec);
    else vec=V3(0,1,0);
    bondir =V3(0,0,0);
    if (bondStrength<ara2)
      bondir= Normalize(bond.at(i).ato1->pos-bond.at(i).ato2->pos)*(0.9*sqrt((ara2*ara2)-bondStrength*bondStrength));
    kurz=sqrt(Norm(bondir));//  */
    //printf("%s--%s kurz %f len %f ara2 %f\n",bond.at(i).ato1->Label.toStdString().c_str(),bond.at(i).ato2->Label.toStdString().c_str(),kurz,bond.at(i).length,ara2);
    glPushMatrix();
    //    glTranslated (mitsav.x,mitsav.y,mitsav.z);
    glTranslated (
    bond.at(i).ato2->pos.x+bondir.x,
    bond.at(i).ato2->pos.y+bondir.y,
    bond.at(i).ato2->pos.z+bondir.z);//Anfangspunkt
    wink=acos(((bond.at(i).ato1->pos.z-bond.at(i).ato2->pos.z)/
                (sqrt((bond.at(i).ato1->pos.x-bond.at(i).ato2->pos.x)*(bond.at(i).ato1->pos.x-bond.at(i).ato2->pos.x)+
                  (bond.at(i).ato1->pos.y-bond.at(i).ato2->pos.y)*(bond.at(i).ato1->pos.y-bond.at(i).ato2->pos.y)+
                  (bond.at(i).ato1->pos.z-bond.at(i).ato2->pos.z)*(bond.at(i).ato1->pos.z-bond.at(i).ato2->pos.z)))))/M_PI*180.0;

    glRotated(wink,vec.x,vec.y,vec.z); // drehen
    GLUquadricObj *q = gluNewQuadric();
    gluQuadricNormals(q, GL_SMOOTH);   // ein Zylinder
    gluQuadricTexture(q,GL_TRUE);
       if (parthigh) {
     glEnable(GL_BLEND);
     QColor pcolor;
     switch (bond.at(i).ato1->part){
         case 1: pcolor=QColor("lightskyblue");break;
         case 2: pcolor=QColor("darkgoldenrod");break;
         case 3: pcolor=Qt::green;break;
         case 4: pcolor=Qt::yellow;break;
         case 5: pcolor=QColor("orange");break;
         case 6: pcolor=Qt::black;break;
         case 7: pcolor=QColor("lightsalmon");break;
         case 8: pcolor=QColor("lightseagreen");break;
         case -1: pcolor=QColor("aquamarine");break;
         case -2: pcolor=QColor("olive");break;
         case -3: pcolor=QColor("bisque");break;
                 case 666: pcolor=QColor("fuchsia");break;
         default: if (bond.at(i).ato1->part>0)
                pcolor=QColor::colorNames().at(qMin(bond.at(i).ato1->part,QColor::colorNames().size()-1));
              else pcolor=Qt::magenta;
     }
     pcolor.setAlpha(140);
     glColor4d(pcolor.redF(),
             pcolor.greenF(),
             pcolor.blueF(),
             pcolor.alphaF());

       }
    //if (trans) {glEnable(GL_BLEND);glEnable(GL_CULL_FACE);}

       //gluCylinder(q, bondStrength*psc, bondStrength*psc, (float)bond.at(i).length/2.0f-kurz, 5*LOD, 1);
       //printf("%g %g %d\n",bondStrength,bond.at(i).length,LOD);
       gluCylinder(q, bondStrength*psc, bondStrength*psc, (float)(bond.at(i).length /2.0f -kurz), 5*LOD, 1);
    //if (trans) {glDisable(GL_BLEND);glDisable(GL_CULL_FACE);}
    glPopMatrix();

    if (bond.at(i).ato1->an>-1){
        glColor4d(Acol[bond.at(i).ato1->an][0],
                        Acol[bond.at(i).ato1->an][1],
                        Acol[bond.at(i).ato1->an][2],
                        Acol[bond.at(i).ato1->an][3]);

    }
    if ((bond.at(i).ato2->sg|bond.at(i).ato1->sg)&&((bond.at(i).ato2->part<0)||(bond.at(i).ato1->part<0))){
      //		    glMaterialfv( GL_FRONT_AND_BACK, GL_EMISSION,blue );
      glColor4d(Acol[bond.at(i).ato1->an][0],
                Acol[bond.at(i).ato1->an][1],
        1.0,
        0.3);
      glEnable(GL_BLEND);
    }

    vec.x=(bond.at(i).ato1->pos.y-bond.at(i).ato2->pos.y);
    vec.y=(bond.at(i).ato2->pos.x-bond.at(i).ato1->pos.x);
    vec.z=0;
    if (Norm(vec)) vec=Normalize(vec);
    else vec=V3(0,1,0);

    bondir =V3(0,0,0);
    if (bondStrength<ara1)
      bondir= Normalize(bond.at(i).ato2->pos-bond.at(i).ato1->pos)*(0.9*sqrt((ara1*ara1)-bondStrength*bondStrength));
    kurz=sqrt(Norm(bondir));// */
    glPushMatrix();
    //    glTranslated (mitsav.x,mitsav.y,mitsav.z);
    glTranslated (
            bond.at(i).ato1->pos.x+bondir.x,
            bond.at(i).ato1->pos.y+bondir.y,
            bond.at(i).ato1->pos.z+bondir.z);//Anfangspunkt
    wink=acos(((bond.at(i).ato2->pos.z-bond.at(i).ato1->pos.z)/
                (sqrt((bond.at(i).ato2->pos.x-bond.at(i).ato1->pos.x)*(bond.at(i).ato2->pos.x-bond.at(i).ato1->pos.x)+
                  (bond.at(i).ato2->pos.y-bond.at(i).ato1->pos.y)*(bond.at(i).ato2->pos.y-bond.at(i).ato1->pos.y)+
                  (bond.at(i).ato2->pos.z-bond.at(i).ato1->pos.z)*(bond.at(i).ato2->pos.z-bond.at(i).ato1->pos.z)))))/M_PI*180.0;
    glRotated(wink,vec.x,vec.y,vec.z); // drehen
    q = gluNewQuadric();
    gluQuadricNormals(q, GL_SMOOTH);   // ein Zylinder
    gluQuadricTexture(q,GL_TRUE);
    //if (trans) {glEnable(GL_BLEND);glEnable(GL_CULL_FACE);}
       if (parthigh) {
     glEnable(GL_BLEND);
     QColor pcolor;
     switch (bond.at(i).ato2->part){
         case 1: pcolor=QColor("lightskyblue");break;
         case 2: pcolor=QColor("darkgoldenrod");break;
         case 3: pcolor=Qt::green;break;
         case 4: pcolor=Qt::yellow;break;
         case 5: pcolor=QColor("orange");break;
         case 6: pcolor=Qt::black;break;
         case 7: pcolor=QColor("lightsalmon");break;
         case 8: pcolor=QColor("lightseagreen");break;
         case -1: pcolor=QColor("aquamarine");break;
         case -2: pcolor=QColor("olive");break;
         case -3: pcolor=QColor("bisque");break;
                 case 666: pcolor=QColor("fuchsia");break;
         default: if (bond.at(i).ato2->part>0)
                pcolor=QColor::colorNames().at(qMin(bond.at(i).ato2->part,QColor::colorNames().size()-1));
              else pcolor=Qt::magenta;
     }
     pcolor.setAlpha(140);
     glColor4d(pcolor.redF(),
             pcolor.greenF(),
             pcolor.blueF(),
             pcolor.alphaF());

       }
    gluCylinder(q, bondStrength*psc, bondStrength*psc, (float)(bond.at(i).length/2.0f-kurz), 5*LOD, 1);
    //printf("%g %g %d\n",bondStrength,bond.at(i).length,LOD);
    gluDeleteQuadric(q);
    glDisable(GL_BLEND);
    glDisable(GL_TEXTURE_2D);
    glPopMatrix();
  }

}

QString molekul::symmcode2human(QStringList brauchSymm){
  QString erg;
  Matrix m;
  V3 t;
  int h,k,l,s;
  for (int j=0; j<brauchSymm.size();j++){
  sscanf(brauchSymm[j].toLatin1(),"%d_%1d%1d%1d",&s,&h,&k,&l);
  h-=5;
  k-=5;
  l-=5;
  s--;
  m=zelle.symmops.at(s);
  QString symstrX,symstrY,symstrZ;
/*  if (m.m11==1) symstrX.append("+x");
  if (m.m11==-1) symstrX.append("-x");
  if (m.m12==1) symstrX.append("+y");
  if (m.m12==-1) symstrX.append("-y");
  if (m.m13==1) symstrX.append("+z");
  if (m.m13==-1) symstrX.append("-z");

  if (m.m21==1) symstrY.append("+x");
  if (m.m21==-1) symstrY.append("-x");
  if (m.m22==1) symstrY.append("+y");
  if (m.m22==-1) symstrY.append("-y");
  if (m.m23==1) symstrY.append("+z");
  if (m.m23==-1) symstrY.append("-z");

  if (m.m31==1) symstrZ.append("+x");
  if (m.m31==-1) symstrZ.append("-x");
  if (m.m32==1) symstrZ.append("+y");
  if (m.m32==-1) symstrZ.append("-y");
  if (m.m33==1) symstrZ.append("+z");
  if (m.m33==-1) symstrZ.append("-z");*/
  if (m.m11==1) symstrX.append("+x");
  if (m.m11==-1) symstrX.append("-x");
  if (m.m21==1) symstrX.append("+y");
  if (m.m21==-1) symstrX.append("-y");
  if (m.m31==1) symstrX.append("+z");
  if (m.m31==-1) symstrX.append("-z");
          
  if (m.m12==1) symstrY.append("+x");
  if (m.m12==-1) symstrY.append("-x");
  if (m.m22==1) symstrY.append("+y");
  if (m.m22==-1) symstrY.append("-y");
  if (m.m32==1) symstrY.append("+z");
  if (m.m32==-1) symstrY.append("-z");
          
  if (m.m13==1) symstrZ.append("+x");
  if (m.m13==-1) symstrZ.append("-x");
  if (m.m23==1) symstrZ.append("+y");
  if (m.m23==-1) symstrZ.append("-y");
  if (m.m33==1) symstrZ.append("+z");
  if (m.m33==-1) symstrZ.append("-z");
  t=zelle.trans.at(s);
  V3 zaehler,nenner;
  double egal;
  for (int g=1;g<5; g++){
    nenner.x=(t.x<0)?-g:g;;
    zaehler.x=(int)((t.x+h)*g);
    if (fabs(modf(t.x*g,&egal))<0.05) break;
  }
  for (int g=1;g<5; g++){
    nenner.y=(t.y<0)?-g:g;
    zaehler.y=(int)((t.y+k)*g);
    if (fabs(modf(t.y*g,&egal))<0.05) break;
  }
  for (int g=1;g<5; g++){
    nenner.z=(t.z<0)?-g:g;
    zaehler.z=(int)((t.z+l)*g);
    if (fabs(modf(t.z*g,&egal))<0.05) break;
  }
  erg.append(QString("%1 ''%2'':<b> %3/%4%5, %6/%7%8, %9/%10%11</b><br>")
		  .arg(j+1)
		  .arg(brauchSymm.at(j))
		  .arg(zaehler.x)
		  .arg(nenner.x)
		  .arg(symstrX)
		  .arg(zaehler.y)
		  .arg(nenner.y)
		  .arg(symstrY)
		  .arg(zaehler.z)
		  .arg(nenner.z)
		  .arg(symstrZ));

  }
  erg.remove(QRegExp("0/\\d"));
  erg.replace("1/1","1");
  erg.replace("2/1","2");
  erg.replace("3/1","3");
  erg.replace("4/1","4");
  erg.replace("5/1","5");
  erg.replace(",,",",");
  return erg;
}

bool molekul::applyLatticeCentro(const QChar latt,const bool centro){
  int z=zelle.symuncent=zelle.symmops.size();
  zelle.centro=centro;
  zelle.lattis=latt;

  Matrix inv(-1.0,0.0,0.0, 0.0,-1.0,0.0, 0.0,0.0,-1.0);
  if (centro) 
    for (int i=0; i<z;i++){
  //    Matrix mm=zelle.symmops.at(i);
      Matrix m=zelle.symmops.at(i)*inv;
      zelle.symmops.append(m);
      zelle.trans.append(zelle.trans.at(i));
//printf("inv\n%g %g %g \n%g %g %g \n%g %g %g \n\n", inv.m11,inv.m12,inv.m13,inv.m21,inv.m22,inv.m23,inv.m31,inv.m32,inv.m33);
//printf("m\n%g %g %g \n%g %g %g \n%g %g %g \n\n", m.m11,m.m12,m.m13,m.m21,m.m22,m.m23,m.m31,m.m32,m.m33);
//printf("om\n%g %g %g \n%g %g %g \n%g %g %g \n\n", mm.m11,mm.m12,mm.m13,mm.m21,mm.m22,mm.m23,mm.m31,mm.m32,mm.m33);
    }
  z=zelle.symmops.size();
  switch (latt.toAscii()){
	  case 'A' :
		  for (int i=0; i<z;i++){
		    V3 tt = zelle.trans.at(i)+V3(0.0, 0.5, 0.5);
		    tt.x=(tt.x>1)?tt.x-1:tt.x;
		    tt.y=(tt.y>1)?tt.y-1:tt.y;
		    tt.z=(tt.z>1)?tt.z-1:tt.z;
		    zelle.symmops.append(zelle.symmops.at(i));
		    zelle.trans.append(tt);
                    if (!zelle.x4sym.isEmpty()){
                    zelle.x4sym.append(zelle.x4sym.at(i));
                    zelle.x4.append(zelle.x4.at(i));
                    zelle.x4tr.append(zelle.x4tr.at(i));
                    }
		  }
		  break;
	  case 'B' :
		  for (int i=0; i<z;i++){
		    V3 tt = zelle.trans.at(i)+V3(0.5, 0.0, 0.5);
		    tt.x=(tt.x>1)?tt.x-1:tt.x;
		    tt.y=(tt.y>1)?tt.y-1:tt.y;
		    tt.z=(tt.z>1)?tt.z-1:tt.z;
		    zelle.symmops.append(zelle.symmops.at(i));
		    zelle.trans.append(tt);
                    if (!zelle.x4sym.isEmpty()){
                    zelle.x4sym.append(zelle.x4sym.at(i));
                    zelle.x4.append(zelle.x4.at(i));
                    zelle.x4tr.append(zelle.x4tr.at(i));
                    }
		  }
		  break;
	  case 'C' :
		  for (int i=0; i<z;i++){
		    V3 tt = zelle.trans.at(i)+V3(0.5, 0.5, 0.0);
		    tt.x=(tt.x>1)?tt.x-1:tt.x;
		    tt.y=(tt.y>1)?tt.y-1:tt.y;
		    tt.z=(tt.z>1)?tt.z-1:tt.z;
		    zelle.symmops.append(zelle.symmops.at(i));
		    zelle.trans.append(tt);
                    if (!zelle.x4sym.isEmpty()){
                    zelle.x4sym.append(zelle.x4sym.at(i));
                    zelle.x4.append(zelle.x4.at(i));
                    zelle.x4tr.append(zelle.x4tr.at(i));
                    }
		  }
		  break;
	  case 'F' :
                  for (int i=0; i<z;i++){
                    V3 tt = zelle.trans.at(i)+V3(0.0, 0.5, 0.5);
                    tt.x=(tt.x>1)?tt.x-1:tt.x;
                    tt.y=(tt.y>1)?tt.y-1:tt.y;
                    tt.z=(tt.z>1)?tt.z-1:tt.z;
                    zelle.symmops.append(zelle.symmops.at(i));
                    zelle.trans.append(tt);
                    if (!zelle.x4sym.isEmpty()){
                      zelle.x4sym.append(zelle.x4sym.at(i));
                      zelle.x4.append(zelle.x4.at(i));
                      zelle.x4tr.append(zelle.x4tr.at(i));
                    }
                    tt = zelle.trans.at(i)+V3(0.5, 0.0, 0.5);
                    tt.x=(tt.x>1)?tt.x-1:tt.x;
                    tt.y=(tt.y>1)?tt.y-1:tt.y;
                    tt.z=(tt.z>1)?tt.z-1:tt.z;
                    zelle.symmops.append(zelle.symmops.at(i));
                    zelle.trans.append(tt);
                    if (!zelle.x4sym.isEmpty()){
                      zelle.x4sym.append(zelle.x4sym.at(i));
                      zelle.x4.append(zelle.x4.at(i));
                      zelle.x4tr.append(zelle.x4tr.at(i));
                    }
                    tt = zelle.trans.at(i)+V3(0.5, 0.5, 0.0);
                    tt.x=(tt.x>1)?tt.x-1:tt.x;
                    tt.y=(tt.y>1)?tt.y-1:tt.y;
                    tt.z=(tt.z>1)?tt.z-1:tt.z;
                    zelle.symmops.append(zelle.symmops.at(i));
                    zelle.trans.append(tt);
                    if (!zelle.x4sym.isEmpty()){
                      zelle.x4sym.append(zelle.x4sym.at(i));
                      zelle.x4.append(zelle.x4.at(i));
                      zelle.x4tr.append(zelle.x4tr.at(i));
                    }
                  }
		  break;
	  case 'I' :
		  for (int i=0; i<z;i++){
		    V3 tt = zelle.trans.at(i)+V3(0.5, 0.5, 0.5);
		    tt.x=(tt.x>1)?tt.x-1:tt.x;
		    tt.y=(tt.y>1)?tt.y-1:tt.y;
		    tt.z=(tt.z>1)?tt.z-1:tt.z;
		    zelle.symmops.append(zelle.symmops.at(i));
		    zelle.trans.append(tt);
                    if (!zelle.x4sym.isEmpty()){
                    zelle.x4sym.append(zelle.x4sym.at(i));
                    zelle.x4.append(zelle.x4.at(i));
                    zelle.x4tr.append(zelle.x4tr.at(i));
                    }
		  }
		  break;
	  case 'R' :
		  for (int i=0; i<z;i++){
		    V3 tt = zelle.trans.at(i)+V3(2.0/3.0, 1.0/3.0, 1.0/3.0);
		    tt.x=(tt.x>1)?tt.x-1:tt.x;
		    tt.y=(tt.y>1)?tt.y-1:tt.y;
		    tt.z=(tt.z>1)?tt.z-1:tt.z;
		    zelle.symmops.append(zelle.symmops.at(i));
		    zelle.trans.append(tt);
		    tt = zelle.trans.at(i)+V3(1.0/3.0, 2.0/3.0, 2.0/3.0);
		    tt.x=(tt.x>1)?tt.x-1:tt.x;
		    tt.y=(tt.y>1)?tt.y-1:tt.y;
		    tt.z=(tt.z>1)?tt.z-1:tt.z;
		    zelle.symmops.append(zelle.symmops.at(i));
		    zelle.trans.append(tt);
                    if (!zelle.x4sym.isEmpty()){
                    zelle.x4sym.append(zelle.x4sym.at(i));
                    zelle.x4.append(zelle.x4.at(i));
                    zelle.x4tr.append(zelle.x4tr.at(i));
                    }
                    if (!zelle.x4sym.isEmpty()){
                    zelle.x4sym.append(zelle.x4sym.at(i));
                    zelle.x4.append(zelle.x4.at(i));
                    zelle.x4tr.append(zelle.x4tr.at(i));
                    }
		  }
		  break;
	  case 'P' :break;  
  //        case 'X' ://jana superspace group centering
  //                  break;
	  default: return false;
  }
  return true;
}

void molekul::setup_zelle(){  
  const double g2r=180.0/M_PI;
  zelle.cs_al = (zelle.al==90)?0:cos(zelle.al/g2r);
  zelle.cs_be = (zelle.be==90)?0:cos(zelle.be/g2r);
  zelle.cs_ga = (zelle.ga==90)?0:cos(zelle.ga/g2r);
//  double
  zelle.sn_al = (zelle.al==90)?1:sin(zelle.al/g2r);
  zelle.sn_be = (zelle.be==90)?1:sin(zelle.be/g2r);
  zelle.sn_ga = (zelle.ga==90)?1:sin(zelle.ga/g2r);

  zelle.phi=  sqrt(1-(zelle.cs_al*zelle.cs_al)-(zelle.cs_be*zelle.cs_be)-(zelle.cs_ga*zelle.cs_ga) + 2*zelle.cs_al*zelle.cs_be*zelle.cs_ga);
  zelle.V = zelle.a*zelle.b*zelle.c*zelle.phi;
  printf("%f %f %f %f %f %f V %f phi %f\n",zelle.a,zelle.b,zelle.c,zelle.al,zelle.be,zelle.ga,zelle.V,zelle.phi);
  printf("%f %f %f %f %f %f \n",zelle.cs_al,zelle.cs_be ,zelle.cs_ga, zelle.sn_al, zelle.sn_be,zelle.sn_ga);
  zelle.as= zelle.c*zelle.b*zelle.sn_al/zelle.V;
  zelle.bs= zelle.c*zelle.a*zelle.sn_be/zelle.V;
  zelle.cs= zelle.a*zelle.b*zelle.sn_ga/zelle.V;
  zelle.cosra=(zelle.cs_be*zelle.cs_ga-zelle.cs_al)/(zelle.sn_be*zelle.sn_ga),
  zelle.cosrb=(zelle.cs_al*zelle.cs_ga-zelle.cs_be)/(zelle.sn_al*zelle.sn_ga),
  zelle.cosrg=(zelle.cs_al*zelle.cs_be-zelle.cs_ga)/(zelle.sn_al*zelle.sn_be);

  zelle.als=acos(zelle.cosra)*g2r;
  zelle.bes=acos(zelle.cosrb)*g2r;
  zelle.gas=acos(zelle.cosrg)*g2r; 
  printf("%f %f %f %f %f %f \n",zelle.cosra,zelle.cosrb,zelle.cosrg,zelle.als,zelle.bes,zelle.gas);
  const double tau=zelle.c*((zelle.cs_al-zelle.cs_be*zelle.cs_ga)/zelle.sn_ga);
  zelle.f2c.m11 = zelle.a;
  zelle.f2c.m21 = 0.0;
  zelle.f2c.m31 = 0.0;
  zelle.f2c.m12 = zelle.b * zelle.cs_ga;
  zelle.f2c.m22 = zelle.b * zelle.sn_ga;
  zelle.f2c.m32 = 0.0;
  zelle.f2c.m13 = zelle.c * zelle.cs_be;
  zelle.f2c.m23 = tau;
  zelle.f2c.m33 = zelle.c * zelle.phi / zelle.sn_ga;

  printf("f2c: \n%12.6f %12.6f %12.6f\n%12.6f %12.6f %12.6f\n%12.6f %12.6f %12.6f\n",zelle.f2c.m11,zelle.f2c.m12,zelle.f2c.m13,zelle.f2c.m21,zelle.f2c.m22
      ,zelle.f2c.m23,zelle.f2c.m31,zelle.f2c.m32, zelle.f2c.m33);
  zelle.G.m11=zelle.a*zelle.a;
  zelle.G.m22=zelle.b*zelle.b;
  zelle.G.m33=zelle.c*zelle.c;
  zelle.G.m12=zelle.G.m21=zelle.a*zelle.b*zelle.cs_ga;
  zelle.G.m13=zelle.G.m31=zelle.a*zelle.c*zelle.cs_be;
  zelle.G.m23=zelle.G.m32=zelle.b*zelle.c*zelle.cs_al;

  zelle.Gi.m11=zelle.as*zelle.as;
  zelle.Gi.m22=zelle.bs*zelle.bs;
  zelle.Gi.m33=zelle.cs*zelle.cs;
  zelle.Gi.m12=zelle.Gi.m21=zelle.as*zelle.bs*zelle.cosrg;
  zelle.Gi.m13=zelle.Gi.m31=zelle.as*zelle.cs*zelle.cosrb;
  zelle.Gi.m23=zelle.Gi.m32=zelle.bs*zelle.cs*zelle.cosra;
  Matrix test=zelle.G*zelle.Gi;
  printf("G   \n%12.6f %12.6f %12.6f\n%12.6f %12.6f %12.6f\n%12.6f %12.6f %12.6f\n",zelle.G.m11,zelle.G.m12,zelle.G.m13,zelle.G.m12,zelle.G.m22,zelle.G.m23,zelle.G.m13,zelle.G.m23,zelle.G.m33 );
  printf("Gi  \n%12.6f %12.6f %12.6f\n%12.6f %12.6f %12.6f\n%12.6f %12.6f %12.6f\n",zelle.Gi.m11,zelle.Gi.m12,zelle.Gi.m13,zelle.Gi.m12,zelle.Gi.m22,zelle.Gi.m23,zelle.Gi.m13,zelle.Gi.m23,zelle.Gi.m33 );
  printf("G*Gi\n%12.6f %12.6f %12.6f\n%12.6f %12.6f %12.6f\n%12.6f %12.6f %12.6f\n",test.m11,test.m12,test.m13,test.m12,test.m22,test.m23,test.m13,test.m23,test.m33 );//*/
}

void molekul::multiplicity(QList<INP> &au){
  V3 hier,da,dort;
  double d;
  for (int i=0; i<au.size(); i++){
    if (au.at(i).OrdZahl<0) continue;
    au[i].multiplicity=0.0;
    hier=clamp3(au.at(i).frac);
    for (int n=0; n<zelle.symmops.size(); n++){
      da = clamp3(zelle.symmops.at(n) * au.at(i).frac + zelle.trans.at(n));
      //da = clamp3(au.at(i).frac * zelle.symmops.at(n) + zelle.trans.at(n));
      d=fl(hier-da);
//      printf("%s %f\n",au.at(i).atomname,d); 
      if (d<0.01) au[i].multiplicity+=1.0;
      for (int j=0; j<au.size(); j++){
        if (i==j) continue;
        if (au.at(j).OrdZahl<0) continue;
        if (au.at(j).OrdZahl!=au.at(i).OrdZahl) continue;
        dort=clamp3(au.at(j).frac);
        d=fl(dort-da);
        //printf("!%s %f\n",au.at(i).atomname,d); 
        if ((au.at(j).OrdZahl==au.at(i).OrdZahl)&&(d<0.01)) au[i].multiplicity+=1.0;//printf ("%s %s ui! %f\n",au.at(i).atomname,au.at(j).atomname,d);
      }
    }
 //   printf("%-8s => multiplicity = %g real occupancy %f\n",au.at(i).atomname,au.at(i).multiplicity, au.at(i).amul*au.at(i).multiplicity);
  }
}

void molekul::Uf2Uo(const Matrix x, Matrix & y) {
  Matrix n=Matrix(zelle.as,0,0,0,zelle.bs,0,0,0,zelle.cs);
  Matrix m=(n*x)*n;
  y=(transponse(zelle.f2c)*m)*(zelle.f2c);
}

double molekul::fl(double x,double y,double z){
  double a,b,c;
  a=(zelle.ga==90.0)?0.0:2.0*x*y*zelle.a*zelle.b*zelle.cs_ga;
  b=(zelle.be==90.0)?0.0:2.0*x*z*zelle.a*zelle.c*zelle.cs_be;
  c=(zelle.al==90.0)?0.0:2.0*y*z*zelle.b*zelle.c*zelle.cs_al;
  double erg=sqrt(x*x*zelle.a*zelle.a+
      y*y*zelle.b*zelle.b+
      z*z*zelle.c*zelle.c+
      a+b+c);
  return erg;
}

double molekul::fl(V3 v){
  double a,b,c;
  a=(zelle.ga==90.0)?0.0:2.0*v.x*v.y*zelle.a*zelle.b*zelle.cs_ga;
  b=(zelle.be==90.0)?0.0:2.0*v.x*v.z*zelle.a*zelle.c*zelle.cs_be;
  c=(zelle.al==90.0)?0.0:2.0*v.y*v.z*zelle.b*zelle.c*zelle.cs_al;
  double erg=sqrt(v.x*v.x*zelle.a*zelle.a+
      v.y*v.y*zelle.b*zelle.b+
      v.z*v.z*zelle.c*zelle.c+
      a+b+c);
  return erg;
}

struct Vert {
  int faces[3];
  V3 pos;
};
int commonFaces(Vert a,Vert b, int f[2]){
  int matches=0; 
  for (int i=0; i<3; i++)
    for (int j=0; j<3; j++)
      if (a.faces[i]==b.faces[j])f[matches++]=a.faces[i];
  return matches;
}

void  molekul::SDMprint(QList<SdmItem> sdm,QList<INP> au){
  printf("          ");
  for (int i=0; i<au.size(); i++) printf("| %6s |",au.at(i).atomname);
  printf("\n"); 
  for (int i=0; i<au.size(); i++) {
    printf(" %6s  |",au.at(i).atomname);
    for (int j=0; j<au.size(); j++) {
      for (int k=0; k<sdm.size(); k++) {
        if ((sdm.at(k).a1==i)&&(sdm.at(k).a2==j)){
          printf("|%8.4f|",sdm.at(k).d);
          break;
        }
      }  
    }
    printf("\n"); 
  }
}

void molekul::voronoij(QList<INP> au, int intat){
  double dk,range=5.0;
  voroMsg.clear();
  voroMsg.append("<b>Voronoi:</b><br>");
  QTime speedTest;
  speedTest.start();
  vtriangles.clear();
  VPoly triangle;
  vorobas=1;
  V3 prime,dp,D,floorD;
  QList<SdmItem> sdm;
  SdmItem sdmItem;
  sdmItem.a1=0;
  sdmItem.a2=1;
  sdmItem.sn=0;
  //sdmItem.p1=sdmItem.p2=V3(0,0,0);
  for (int i=0; i<au.size(); i++){ 
    for (int j=0; j<au.size(); j++ ){
      if ((au.at(i).sg)||(au.at(j).sg)) continue;
      //  bool hma=false;
      for (int n=0;n<zelle.symmops.size();  n++){
        prime=zelle.symmops.at(n) * au.at(i).frac + zelle.trans.at(n);
        D=prime - au.at(j).frac+ V3(0.5,0.5,0.5) ;
        floorD=V3(floor(D.x),floor(D.y),floor(D.z));
        for (int h=-1; h<2; h++){
          for (int k=-1; k<2; k++){
            for (int l=-1; l<2; l++){
              V3 fD=floorD+V3(h,k,l);  
              dp=D - fD - V3(0.5,0.5,0.5);
              dk=fl(dp.x,dp.y,dp.z);
              if ((dk>0.01)&&((range)>=dk)){
                sdmItem.d=dk;
                sdmItem.floorD=fD;
                sdmItem.a1=i;
                sdmItem.a2=j;
                sdmItem.sn=n;
                sdm.append(sdmItem);
              }
            }
          }
        }
      }
    }
  }
  qSort(sdm.begin(),sdm.end());
  SDMprint(sdm,au);
  QList<V3> n,m,doneLine;
  QList<int> intra;
  QList<Vert> v;
  Vert vert;
  V3 pf,pc,mx,nx,of,oc;
  Matrix mat;
  double vol=0.0,avol,tvol;
  for (int i=(intat>-1)?intat:0; i<au.size(); i++){
    if (au.at(i).OrdZahl<0) continue;
    //find faces
    n.clear();
    m.clear();
    v.clear();
    doneLine.clear();
    intra.clear();
    avol=0.0;
    int faci=0;
    //int vcnt=0;
    frac2kart(au.at(i).frac,oc);
    int tris=0;
    for (int j=0; j<sdm.size();j++){
      if(sdm.at(j).d<0.1) continue;
      if ((sdm.at(j).a2==i)&&(au[sdm.at(j).a1].OrdZahl>-1)) {
        pf= zelle.symmops.at(sdm.at(j).sn) * au[sdm.at(j).a1].frac + zelle.trans.at(sdm.at(j).sn) - sdm.at(j).floorD;
        frac2kart(pf,pc);
        /*
           printf("%9.5f %9.5f %9.5f  %9.5f %9.5f %9.5f\n"
           ,oc.x
           ,oc.y
           ,oc.z
           ,pc.x
           ,pc.y
           ,pc.z
           );// */
        mx=0.5*(oc+pc);
        nx=Normalize(pc-oc);
        bool exists=false;double dpl;
        for (int tp=0; tp<m.size(); tp++){
        dpl=n.at(tp)*(mx-m.at(tp));
        if (fabs(dpl)<0.001){exists=true;break;}
        }
        if (!exists){
        m.append(mx);
        n.append(nx);
        intra.append((sdm.at(j).sn==0)&&(Norm(sdm.at(j).floorD)==0.0));
        }
      }//is neighbour of i
    }// j sdm
    for (int h=0; h<n.size()-2; h++)
      for (int k=h+1; k<n.size()-1; k++)
        for (int l=k+1; l<n.size(); l++){
          mat=Matrix(n.at(h),n.at(k),n.at(l));
          double d=determinant(mat),dpl;
          //printf("%d,%d,%d %9.5f\n",h,k,l,d);
          if (fabs(d)<0.0002) continue;

          //p = (dot(p1,n1)*cross(n2,n3)-dot(p2,n2)*cross(n1,n3)+dot(p3,n3)*cross(n1,n2))/d 
          bool out=false;
          vert.pos=(
              (m.at(h)*n.at(h))*(n.at(k)%n.at(l))+
              (m.at(k)*n.at(k))*(n.at(l)%n.at(h))+
              (m.at(l)*n.at(l))*(n.at(h)%n.at(k)))*(1.0/d);
          vert.faces[0]=h;
          vert.faces[1]=k;
          vert.faces[2]=l;
          for (int pli=0; pli<n.size(); pli++){//teste lage zu allen ebenen
            dpl=n.at(pli)*(vert.pos-m.at(pli));
            if (dpl>0.00001) {
              out=true;
              break;
            }
          }
          if (!out) {
            v.append(vert);
          //  printf("[%d,%d,%d] %9.5f%9.5f%9.5f  \n",h,k,l,vert.pos.x,vert.pos.y,vert.pos.z);
          }
        }
    for (int mi=0; mi<m.size();mi++){// this is to get the midpoint of a face in its actual center
      V3 mnew=V3(0,0,0);
      int poli=0;
      for (int vi=0; vi<v.size(); vi++){
      if ((v.at(vi).faces[0]==mi)||(v.at(vi).faces[1]==mi)||(v.at(vi).faces[2]==mi)){
      mnew+=v.at(vi).pos;
      poli++;
      }
      }
      mnew*=1.0/poli;
//      printf("%dsoll 0=%f\n",poli,n.at(mi)*(mnew-m.at(mi)));
      if (poli) {m[mi]=mnew;faci++;}
    }
/*    glBegin(GL_LINES);
    for(int vi=0; vi<v.size()-1; vi++)
      for(int vj=vi+1; vj<v.size(); vj++){
        int fc[2];
        if (commonFaces(v.at(vi),v.at(vj),fc)==2){
          glColor4fv(Acol[au[i].OrdZahl]);
          glVertex3d(v.at(vi).pos.x,v.at(vi).pos.y,v.at(vi).pos.z);
          glVertex3d(v.at(vj).pos.x,v.at(vj).pos.y,v.at(vj).pos.z);
        }  
      }
    glEnd();*/
//      glBegin(GL_TRIANGLES);
      //glBegin(GL_LINES);

    for(int vi=0; vi<v.size()-1; vi++)
      for(int vj=vi+1; vj<v.size(); vj++){
        int fc[2];
        if (commonFaces(v.at(vi),v.at(vj),fc)==2){
          V3 lin=v.at(vi).pos+v.at(vj).pos;
          double dis;
          bool done=false;
          for (int di=0; di<doneLine.size(); di++){
            dis=Distance(lin,doneLine.at(di));
            if (dis<0.000001) {done=true; break;}
          }
          if (done) continue;
          doneLine.append(lin);
          tvol=determinant(Matrix(m.at(fc[0])-oc, v.at(vi).pos-oc,v.at(vj).pos-oc));
          int v1=(tvol<0)?vj:vi,
              v2=(tvol<0)?vi:vj;
          triangle.mid=m.at(fc[0]);
          triangle.nor=n.at(fc[0]);
          triangle.acol=au[i].OrdZahl;
          triangle.intra=intra.at(fc[0]);
          triangle.verts0=v[v1].pos;
          triangle.verts1=v[v2].pos;
          
          vtriangles.append(triangle);
          /*
          GLfloat colo[4]={ Acol[au[i].OrdZahl][0], Acol[au[i].OrdZahl][1], Acol[au[i].OrdZahl][2], 0.4};
          //GLfloat colo[4]={ Acol[tris%100][0], Acol[tris%100][1], Acol[tris%100][2], 0.4};
          colo[3]=intra.at(fc[0])?1.0:0.4;
          glColor4fv(colo);
          glNormal3d(n.at(fc[0]).x,n.at(fc[0]).y,n.at(fc[0]).z);
          glVertex3d(m.at(fc[0]).x,m.at(fc[0]).y,m.at(fc[0]).z);
          glVertex3d(v.at(v1).pos.x,v.at(v1).pos.y,v.at(v1).pos.z);
          glVertex3d(v.at(v2).pos.x,v.at(v2).pos.y,v.at(v2).pos.z);
          */
          tris++;
          double tv=fabs(tvol)/6.0;
          avol+=tv;
          vol+=tv*au[i].amul;
          tvol=determinant(Matrix(m.at(fc[1])-oc, v.at(vi).pos-oc,v.at(vj).pos-oc));
          v1=(tvol<0)?vj:vi;
          v2=(tvol<0)?vi:vj;
          triangle.mid=m.at(fc[1]);
          triangle.nor=n.at(fc[1]);
          triangle.acol=au[i].OrdZahl;
          triangle.intra=intra.at(fc[1]);
 //         triangle.col[3]=((intat>-1)&&(intra.at(fc[1])))?0.8:0.4;
          triangle.verts0=v[v1].pos;
          triangle.verts1=v[v2].pos;
          vtriangles.append(triangle);
          /*
          colo[3]=intra.at(fc[1])?1.0:0.4;
          glColor4fv(colo);

          glNormal3d(n.at(fc[1]).x,n.at(fc[1]).y,n.at(fc[1]).z);
          glVertex3d(m.at(fc[1]).x,m.at(fc[1]).y,m.at(fc[1]).z);
          glVertex3d(v.at(v1).pos.x,v.at(v1).pos.y,v.at(v1).pos.z);
          glVertex3d(v.at(v2).pos.x,v.at(v2).pos.y,v.at(v2).pos.z);
          */
          tris++;
          tv=fabs(tvol)/6.0;
          avol+=tv;
          vol+=tv*au[i].amul;
        }  
      } 
//    glEnd();
//    printf("%d neighbours found for %s. Voronoij polyeder has %d verices, %d edges and %d faces. Triangles %d Volume %f Total Volume= %f cell volume %f\n",
//        m.size(),au.at(i).atomname,v.size(),v.size()+m.size()-2,m.size(),
        printf("%-12s: Triangles %6d Volume %18.5f %d\n",au.at(i).atomname,tris,avol,-tris/2+faci+v.size());
        voroMsg.append(QString("%1 : EulerTest: %2 Volume %3 &Aring;<sup>3</sup>.<br>").arg(au.at(i).atomname).arg(-tris/2+faci+v.size()).arg(avol));

    if (intat>-1) break;
  }//i atoms au
  if (intat==-1) {
  printf("Total Volume= %18.5f Total Volume * z = %18.5f cell volume %18.5f delta =%f%%\n",vol,vol*zelle.symmops.size(),zelle.V,
      (vol*zelle.symmops.size()-zelle.V)/zelle.V*100.0
      );
  voroMsg.append(QString("Total Volume= %1 &Aring;<sup>3</sup> cell volume %2 &Aring;<sup>3</sup> &Delta;V %3%<br>").arg(vol*zelle.symmops.size()).arg(zelle.V).arg((vol*zelle.symmops.size()-zelle.V)/zelle.V*100.0));
  }
//  printf("drawing %dms\n",speedTest.restart());
}

V3 eye;
bool vbyeye(VPoly a,VPoly b){
return (Distance(a.mid,eye)>Distance(b.mid,eye));
}

void molekul::drawVoronoi(V3 auge){
  eye=auge;
  qSort(vtriangles.begin(),vtriangles.end(),vbyeye);
  glDisable(GL_CULL_FACE);
  glEnable(GL_BLEND);
  glDisable(GL_LIGHTING);
  glBegin(GL_LINES);
  for (int ti=0; ti<vtriangles.size(); ti++){
    glColor4fv(Acol[vtriangles.at(ti).acol]);
    glVertex3d(vtriangles.at(ti).verts0.x,vtriangles.at(ti).verts0.y,vtriangles.at(ti).verts0.z);
    glVertex3d(vtriangles.at(ti).verts1.x,vtriangles.at(ti).verts1.y,vtriangles.at(ti).verts1.z);
  }  
  glEnd();
  glEnable(GL_LIGHTING);
  glBegin(GL_TRIANGLES);
  for (int ti=0; ti<vtriangles.size(); ti++){
    glColor4f(
        Acol[vtriangles.at(ti).acol][0],
        Acol[vtriangles.at(ti).acol][1],
        Acol[vtriangles.at(ti).acol][2],
        (vtriangles.at(ti).intra)?0.1:0.4
        );
//    Farbverlauf(ti,0,vtriangles.size(),0.2);
    glNormal3d(vtriangles.at(ti).nor.x,vtriangles.at(ti).nor.y,vtriangles.at(ti).nor.z);
    glVertex3d(vtriangles.at(ti).mid.x,vtriangles.at(ti).mid.y,vtriangles.at(ti).mid.z);
    glVertex3d(vtriangles.at(ti).verts0.x,vtriangles.at(ti).verts0.y,vtriangles.at(ti).verts0.z);
    glVertex3d(vtriangles.at(ti).verts1.x,vtriangles.at(ti).verts1.y,vtriangles.at(ti).verts1.z);
  }
  glEnd();
//  glEndList();
}
///////////////

void printMatrix(Matrix a){
  printf("%10.6f%10.6f%10.6f\n%10.6f%10.6f%10.6f\n%10.6f%10.6f%10.6f\n"
      ,a.m11, a.m21, a.m31, a.m12, a.m22, a.m32, a.m13, a.m23, a.m33);

}
Modulat Modulat::applySymm(Matrix sym3d, V3 trans3d, V3 x4sym, int x4,double x4trans){
  if ((x4!=1)&&(x4!=-1)) {
    fprintf(stderr,"shit %d %f %f %f %f \n",x4,x4trans,x4sym.x,x4sym.y,x4sym.z);
    exit(1);
  
  }
  Modulat that=*this;
  Modulat *newatom=new Modulat(that);
//  printMatrix(sym3d);
//  printf("tra %f %f %f \n",trans3d.x,trans3d.y,trans3d.z);
  newatom->frac0=(sym3d*frac0)+trans3d;
//  printf(" %f %f %f  === %f %f %f \n",frac0.x,frac0.y,frac0.z,newatom->frac0.x,newatom->frac0.y,newatom->frac0.z);
  //  printf("applySymm %d = %d %d = %d %d = %d\n",newatom->wo,newatom->os.size(),newatom->wp,newatom->possin.size(),newatom->wt,newatom->usin.size());
  for (int i=0; i<wp;i++){
    //  printf("%sfrac o sin %g %g %g cos %g %g %g\n",atomname,possin[i].x,possin[i].y,possin[i].z,poscos[i].x,poscos[i].y,poscos[i].z);
    newatom->possin[i]=possin[i]*sym3d;
    newatom->poscos[i]=poscos[i]*sym3d;
    //    printf("%sfrac wp%d sin %g %g %g cos %g %g %g %p\n",atomname,i,newatom->possin[i].x,newatom->possin[i].y,newatom->possin[i].z,newatom->poscos[i].x,newatom->poscos[i].y,newatom->poscos[i].z,newatom);
  }
  if (sp){
    int i=wp-1;
    //newatom->possin[i]=possin[i];
    newatom->poscos[i]=poscos[i];
  }
  newatom->uf0=(sym3d*uf0)*transponse(sym3d);
  for (int i=0; i<wt; i++){
    newatom->usin[i]=(sym3d*usin[i])*transponse(sym3d);
    newatom->ucos[i]=(sym3d*ucos[i])*transponse(sym3d);
  }
  newatom->x4sym=x4sym;
  newatom->x4=x4;
  newatom->x4trans=x4trans;
  return *newatom;
}
  const V3 Modulat::kart(const double t, bool *outside2){
    V3 p=frac(t);
    if (outside2!=NULL){
    *outside2=((p.x>1.5)||(p.y>1.5)||(p.z>1.5)||(p.x<-0.5)||(p.y<-0.5)||(p.z<-0.5));
    }
    V3 y;

    y.x = p.x * mol->zelle.f2c.m11 + p.y * mol->zelle.f2c.m12 + p.z * mol->zelle.f2c.m13;
    y.y = p.x * mol->zelle.f2c.m21 + p.y * mol->zelle.f2c.m22 + p.z * mol->zelle.f2c.m23;
    y.z = p.x * mol->zelle.f2c.m31 + p.y * mol->zelle.f2c.m32 + p.z * mol->zelle.f2c.m33;
    return y;
  }
double clamp2(double x){
  double xx=x+99.5;
int i=(int)(xx);
return (xx-i)-0.5;
}
const V3 Modulat::frac(const double t){
  V3 p=frac0;
  double X4=0.0;
  if (iamcomp>1){
    V3 qnu=mol->ccc.at(iamcomp-2).nuCell.qvec;
    //  X4 = mol->ccc[iamcomp-2].wnudd()*t+ (mol->ccc.at(iamcomp-2).nuCell.qvec*(frac0-mol->ccc[iamcomp-2].oschi(t)));
    //  printf("%s X4' t = %f %f (%f %f %f)\n",atomname,t,X4,qnu.x,qnu.y,qnu.z);
    X4 = mol->ccc.at(iamcomp-2).tfactor*t+ (qnu*frac0);
    //    printf("%s X4 %f (%f %f %f)\n",atomname,X4,qnu.x,qnu.y,qnu.z);

    X4 = (x4sym*(frac0-mol->ccc[iamcomp-2].oschi(t)))+x4*X4+x4trans;
    //    printf("%s X4 %f (%f %f %f)\n",atomname,X4,qnu.x,qnu.y,qnu.z);
  }else{  
    X4 = t+(mol->zelle.qvec*frac0);
    X4 = (x4sym*frac0)+x4*X4+x4trans;
  }
  double ig=1;
  X4=modf(X4+99,&ig);
  if (polytype<2){
    switch (sp) {
      case 0:
        for (int i=0; i<wp;i++){
          p+=possin[i] * mol->modscal *sin(2*M_PI*(i+1)*X4);
          p+=poscos[i] * mol->modscal *cos(2*M_PI*(i+1)*X4);
        }
        break;
      case 1://sawtooth
        {
          for (int i=0; i<wp-1;i++){
            p+=possin[i] * mol->modscal *sin(2*M_PI*(i+1)*X4);
            p+=poscos[i] * mol->modscal *cos(2*M_PI*(i+1)*X4);
          }
          double x4s=poscos[wp-1].x;
          double delta=poscos[wp-1].y*0.5;
          x4s=clamp2(X4-x4s);
          x4s/=delta;
          p+=possin[wp-1]*x4s;
        }
        break;
      case 2://zigzag
        {
          for (int i=0; i<wp-1;i++){
            p+=possin[i] * mol->modscal *sin(2*M_PI*(i+1)*X4);
            p+=poscos[i] * mol->modscal *cos(2*M_PI*(i+1)*X4);
          }
          double x4s=poscos[wp-1].x;
          double delta=poscos[wp-1].y*0.5;
          x4s=clamp2(X4-x4s);
          x4s=((x4s>-delta)&&(x4s<delta))?x4s:-clamp2(x4s+0.5);
          x4s/=delta;
          p+=possin[wp-1]*x4s;
        }
        break;
    }
  } else {
    double delta=0.5*o;
    double pom=(X4-os[0])/delta;
    getFPol(pom,wp*2+1,polytype);
    for (int i=0; i<wp;i++){
      p+=possin[i] * mol->modscal *fpol[2*i+2];
      p+=poscos[i] * mol->modscal *fpol[2*i+3];
    }
  }
  if (iamcomp>1){
    p = p-mol->ccc[iamcomp-2].oschi(t);
    p = mol->ccc.at(iamcomp-2).toCommon*p;
  }
  
  if (mol->zelle.commensurate){

    p.x = p.x/mol->zelle.commen.x;
    p.y = p.y/mol->zelle.commen.y;
    p.z = p.z/mol->zelle.commen.x;
    p = clamp3(p);
    p.x = p.x*mol->zelle.commen.x;
    p.y = p.y*mol->zelle.commen.y;
    p.z = p.z*mol->zelle.commen.x;
    mol->bonds_made=0;
  }
  return p;
}
const V3 Modulat::displacement(const double t){
  V3 p=V3(0,0,0);
  double X4=t+(mol->zelle.qvec*frac0);
  X4=(x4sym*frac0)+x4*X4+x4trans;
  double ig=1;
  X4=modf(X4+99,&ig);
  if (polytype<2){
    switch (sp) {
      case 0:
        for (int i=0; i<wp;i++){
          p+=possin[i]*sin(2*M_PI*(i+1)*X4);
          p+=poscos[i]*cos(2*M_PI*(i+1)*X4);
        }
        break;
      case 1://sawtooth
        {
        for (int i=0; i<wp-1;i++){
          p+=possin[i]*sin(2*M_PI*(i+1)*X4);
          p+=poscos[i]*cos(2*M_PI*(i+1)*X4);
        }
        double x4s=poscos[wp-1].x;
        double delta=poscos[wp-1].y*0.5;
        x4s=clamp2(X4-x4s);
        x4s/=delta;
        p+=possin[wp-1]*x4s;
        }
        break;
      case 2://zigzag
        {
        for (int i=0; i<wp-1;i++){
          p+=possin[i]*sin(2*M_PI*(i+1)*X4);
          p+=poscos[i]*cos(2*M_PI*(i+1)*X4);
        }
        double x4s=poscos[wp-1].x;
        double delta=poscos[wp-1].y*0.5;
        x4s=clamp2(X4-x4s);
        x4s=((x4s>-delta)&&(x4s<delta))?x4s:-clamp2(x4s+0.5);
        x4s/=delta;
        p+=possin[wp-1]*x4s;
        }
        break;
    }
  } else {
    double delta=0.5*o;
    double pom=(X4-os[0])/delta;
    getFPol(pom,wp*2+1,polytype);
    for (int i=0; i<wp;i++){
      p+=possin[i]*fpol[2*i+2];
      p+=poscos[i]*fpol[2*i+3];
    }
  } 
  return p;
}
double Modulat::occupancy(double t){
    double ooo=1.0;
  double X4=t+(mol->zelle.qvec*frac0);
  //  printf("%sfrac X4 %g frac0 %g %g %g t%g\n",atomname,X4,frac0.x,frac0.y,frac0.z,t);
  X4=(x4sym*frac0)+x4*X4+x4trans;
  double ig=1;
  X4=modf(X4+99.0,&ig);

    switch (sp) {
      case 1://sawtooth
        {
          double x4s=poscos[wp-1].x;
          double delta=poscos[wp-1].y*0.5;
          x4s=clamp2(X4-x4s);
          ooo=((x4s<delta)&&(x4s>-delta))?1.0:0.0;
        }
        break;
      case 2://zigzag
        {
          double x4s=poscos[wp-1].x;
          double delta=poscos[wp-1].y*0.5;
          x4s=clamp2(X4-x4s);
          x4s=((x4s>-delta)&&(x4s<delta))?x4s:-clamp2(x4s+0.5);
          x4s/=delta;
        }
        break;
    }
    //*/
  if (wo==0) return ooo;
  double occup=0.0;
  switch (so){
    case 0: //harmonic occupancy function
      occup = o;
      for (int i=0; i<wo;i++){
        occup+=os[i]*sin(2*M_PI*(i+1)*X4);
        occup+=oc[i]*cos(2*M_PI*(i+1)*X4);
      }
      break;
    case 1: //crenel function
      occup = ((X4>(os[0]-o/2.0)) && (X4<(os[0]+o/2.0)))?1.0:0.0;
   //   printf("crenel function wo%d so%d  %f <%f< %f o=%f %f %f -->>%f\n",wo,so,(os[0]-o/2.0),X4,(os[0]+o/2.0),o,os[0],oc[0],occup );
      break;
  }
  return occup;
}

Matrix Modulat::uf(double t){
  Matrix m=uf0;
  if (jtf==1) {
    m.m33=m.m22=m.m11;
    m.m12=m.m11*mol->zelle.cosrg;
    m.m13=m.m11*mol->zelle.cosrb;
    m.m23=m.m11*mol->zelle.cosra;
  }
  //  if (OrdZahl==0){ printf("%-9s %g %g %g %g %g %g\n",atomname,m.m11, m.m22, m.m33, m.m12, m.m13, m.m23); }
  double X4=t+(mol->zelle.qvec*frac0);
  X4=(x4sym*frac0)+x4*X4+x4trans;
  double ig=1;
  X4=modf(X4+99.0,&ig);
  double cs,sn;
  if (polytype<2){
    for (int i=0; i<wt;i++){
      sn=sin(2*M_PI*(i+1)*X4);
      cs=cos(2*M_PI*(i+1)*X4);

      m.m11+=usin[i].m11*sn;
      m.m22+=usin[i].m22*sn;
      m.m33+=usin[i].m33*sn;
      m.m12+=usin[i].m12*sn;
      m.m13+=usin[i].m13*sn;
      m.m23+=usin[i].m23*sn;

      m.m11+=ucos[i].m11*cs;
      m.m22+=ucos[i].m22*cs;
      m.m33+=ucos[i].m33*cs;
      m.m12+=ucos[i].m12*cs;
      m.m13+=ucos[i].m13*cs;
      m.m23+=ucos[i].m23*cs;
    }
  } else {
    double delta=0.5*o;
    double pom=(X4-os[0])/delta;
    getFPol(pom,wt*2+1,polytype);
    for (int i=0; i<wt;i++){
      sn=fpol[2*i+2];
      cs=fpol[2*i+3];
      m.m11+=usin[i].m11*sn;
      m.m22+=usin[i].m22*sn;
      m.m33+=usin[i].m33*sn;
      m.m12+=usin[i].m12*sn;
      m.m13+=usin[i].m13*sn;
      m.m23+=usin[i].m23*sn;

      m.m11+=ucos[i].m11*cs;
      m.m22+=ucos[i].m22*cs;
      m.m33+=ucos[i].m33*cs;
      m.m12+=ucos[i].m12*cs;
      m.m13+=ucos[i].m13*cs;
      m.m23+=ucos[i].m23*cs;
    }
  } 
  m.m21=m.m12;
  m.m31=m.m13;
  m.m32=m.m23;
  return m;
}

Matrix Modulat::u(double t){
  Matrix x=uf(t);
  Matrix n=Matrix(mol->zelle.as,0,0,0,mol->zelle.bs,0,0,0,mol->zelle.cs);
  Matrix m=(n*x)*n;
 // Matrix y=(mol->zelle.f2c*m)*transponse(mol->zelle.f2c);
  Matrix y=(transponse(mol->zelle.f2c)*m)*(mol->zelle.f2c);
//  printf("Uc? jtf%d %f %f %f %f %f %f\n",jtf,y.m11,y.m22,y.m33,y.m12,y.m13,y.m23);
  return y;
}

  void Modulat::errorMsg(QString msg){
    qDebug()<<msg;
  }

INP Modulat::toINP(double t){
    INP atom;
    strcpy(atom.atomname,atomname);
    atom.lflag=atom.icor1=atom.icor2=atom.nax=atom.nay1=atom.nay2=atom.na3=0;
    atom.jtf=2;
    atom.atomtype=1;
    atom.noofkappa=atom.lmax=atom.isym=atom.ichcon=0;
    atom.amul=occupancy(t)*amul;
    atom.imul=imul;
    atom.frac=frac(t);
    atom.kart=kart(t);
    atom.OrdZahl=OrdZahl;
    atom.part=atom.resiNr=0;  
    atom.sg=sg;
    atom.molindex=molindex;
    atom.screenX=screenX;
    atom.screenY=screenY;
    return atom;
  }


void Modulat::makeXHarmOrtho0(double *xmat, int nd){
  int nd2=nd*nd;
//  int n2=nd*(nd+1)/2;
  double *gmat=(double*) malloc(sizeof(double)*nd2);
  double harm;
  for (int i=0; i<nd; i++)
    for (int j=0; j<=i; j++){
      harm=scProdXHarm0(i,j);
//      printf("C %d %d %f ===>> %f %d\n",i+1,j+1,harm,scProdXHarm(i+1,j+1),xyn0(i,j,nd));
      if (i!=j) gmat[xyn0(j,i,nd)]=harm;
      gmat[xyn0(i,j,nd)]=harm;
    }
  double aj,pom;
  for (int n=0; n<nd; n++){
   // printf("y %d\n", n);
    for (int i=0; i<nd; i++) xmat[xyn0(n,i,nd)]=0.0;
    for (int j=0; j<n; j++) {
      aj=0.0;
      for (int k=0; k<=j; k++) aj-=xmat[xyn0(j,k,nd)]*gmat[xyn0(k,n,nd)];
     // printf("aj%f n%d j%d\n",aj,n,j);
      for (int k=0; k<=j; k++) xmat[xyn0(n,k,nd)]+=aj*xmat[xyn0(j,k,nd)];

    }
    xmat[xyn0(n,n,nd)]=1.0;
    pom=0.0;
    for (int i=0; i<=n; i++) 
      for (int j=0; j<=n; j++) {
        pom+=xmat[xyn0(n,i,nd)]*xmat[xyn0(n,j,nd)]*gmat[xyn0(i,j,nd)];
      }
   // printf("pom%d: %f\n",n,pom);
    pom=(pom>0.0)?1.0/sqrt(pom):0.0;
    for (int i=0; i<=n; i++) {
      xmat[xyn0(n,i,nd)]=((i!=n)||(pom!=0.0))?xmat[xyn0(n,i,nd)]*pom:1.0;
//      if (!(i%2)&&!(n%2)) printf("(%2d_%2d %10.7f) ",n+1,i+1,xmat[xyn0(n,i,nd)]);
    }
//    if (!(n%2)) printf("\n");
  }
  free(gmat);
}
double Modulat::xHarmOrtho(double x, int n, double *xmat, int nd){ 
  double res=0.0;
  for (int i=1; i<=n; i++){
    if (fabs(xmat[xyn(n,i,nd)])<0.000001) continue;
    if (i==1) res+=xmat[xyn(n,i,nd)]*x;
    else{
      int j=(i)/2;
      res+=(i%2)?
        xmat[xyn(n,i,nd)]*sin(M_PI*j*x):
        xmat[xyn(n,i,nd)]*cos(M_PI*j*x);
    }
  } return res;
}

void Modulat::getFPol(double x, int npol, int type){
  static int nalloc=0;
  static double *xmat=NULL;
  if (type==2){
    fLegendre(x,npol);
  }
  else if (type==3){
    fpol[1]=1.0;
    if ((npol-1) >nalloc){
      if (xmat!=NULL) free(xmat);
      xmat=(double*) malloc(sizeof(double)*(npol-1)*(npol-1));
      nalloc=npol-1;
      makeXHarmOrtho0(xmat,nalloc);
      //makeXHarmOrtho(xmat,nalloc);
    }
    for (int i=2; i<=npol; i++) fpol[i]=xHarmOrtho(x,i-1,xmat,nalloc);
  } 
}

QString Modulat::plotT(int steps){
      double fact=1.0;
      if (iamcomp>1) fact=mol->ccc[iamcomp-2].tfactor;
      double t=0.0,stepwidth=1.0/(steps*fact);
      V3 p,fr;
      QString text=QString("#%1 %2 steps (%3 %4 %5) %6 %7 %8 %9 %10\n#t           occupancy  xfract.    yfract.    zfract.    displacements                    umin       umean      umax\n").arg(atomname).arg(steps)
        .arg(x4sym.x)
        .arg(x4sym.y)
        .arg(x4sym.z)
        .arg(x4) 
        .arg(x4trans)
        .arg((so==1)?"crenel function":"")
        .arg((sp==0)?"":(sp==1)?"sawtooth fuction":"zig-zag")
        .arg((polytype==0)?"":(polytype==2)?"Legendre polynoms":(polytype==3)?"XHarmonic":"unknown polynom")
        ;
      double occ=0.0;
      Matrix ucc;
      V3 ev=V3(0,0,0),sev=V3(0,0,0);
      for (int i=0; i<=steps; i++){
        occ=occupancy(t);
        if (occ<0.1) {
          t+=stepwidth;
          continue;
        }
        fr=frac(t);
        p=displacement(t);

        ucc=u(t);
        ev=V3(0,0,0);
        mol->jacobi2(ucc,ev);
        int chos1=(ev.x<ev.y)?(ev.x<ev.z)?1:3:(ev.z<ev.y)?3:2;

        int chos2=(ev.x>ev.y)?(ev.x>ev.z)?1:3:(ev.z>ev.y)?3:2;
        switch (chos1){
        case 1:sev.x=ev.x;break;
        case 2:sev.x=ev.y;break;
        case 3:sev.x=ev.z;break;
        }
        switch (chos2){
        case 1:sev.z=ev.x;break;
        case 2:sev.z=ev.y;break;
        case 3:sev.z=ev.z;break;
        }
        int chose3=6-chos1-chos2;
        switch (chose3){
        case 1:sev.y=ev.x;break;
        case 2:sev.y=ev.y;break;
        case 3:sev.y=ev.z;break;
        }
        text.append(QString("%1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11\n")
            .arg(t,10,'f',6)
            .arg(occ,10,'f',6)
            .arg(fr.x,10,'f',6)
            .arg(fr.y,10,'f',6)
            .arg(fr.z,10,'f',6)
            .arg(p.x*mol->zelle.a,10,'f',6)
            .arg(p.y*mol->zelle.b,10,'f',6)
            .arg(p.z*mol->zelle.c,10,'f',6)
                    .arg(sev.x,10,'f',6)
                    .arg(sev.y,10,'f',6)
                    .arg(sev.z,10,'f',6)
                    );
//        printf("%5.2f (%10.6f) %10.6f%10.6f%10.6f  %10.6f%10.6f%10.6f\n",t,occ,fr.x,fr.y,fr.z,p.x,p.y,p.z);
        t+=stepwidth;
      }
      return text;
    }
void JanaMolecule::printpos(const double t,QList<Modulat> &ma){
  const double g2r=180.0/M_PI;
  Matrix f2c=atoms.at(0).mol->zelle.f2c;
  Matrix c2f=inverse(f2c);
  Matrix R;
  if (!refp.isEmpty()) 
    for(int j=0;j<atoms.size();j++){
      if (refp==QString(atoms.at(j).atomname)) {
        ref=atoms[j].frac0; 
        break;
      }
    }
  for (int i=0; i<positions.size();i++){
    R=(lrot==0)?
      Matrix(
          cos(positions.at(i).phi/g2r),     -sin(positions.at(i).phi/g2r),0.,
          sin(positions.at(i).phi/g2r),      cos(positions.at(i).phi/g2r),0.,
          0.,0.,1.0)*
      Matrix(
          1.0,0.,0.,
          0., cos(positions.at(i).chi/g2r),    -sin(positions.at(i).chi/g2r),
          0., sin(positions.at(i).chi/g2r),     cos(positions.at(i).chi/g2r))*
      Matrix(
          cos(positions.at(i).psi/g2r),     -sin(positions.at(i).psi/g2r),0.,
          sin(positions.at(i).psi/g2r),      cos(positions.at(i).psi/g2r),0., 
          0.,0.,1.0)*f2c
      :
      Matrix(
          cos(positions.at(i).phi/g2r),     -sin(positions.at(i).phi/g2r),0.,
          sin(positions.at(i).phi/g2r),      cos(positions.at(i).phi/g2r),0.,
          0.,0.,1.0)*
      Matrix(
          cos(positions.at(i).chi/g2r), 0.,    sin(positions.at(i).chi/g2r),
          0.,1.0,0.,
          -sin(positions.at(i).chi/g2r), 0.,   cos(positions.at(i).chi/g2r))*
      Matrix(
          1.0,0.,0.,
          0.,cos(positions.at(i).psi/g2r),     -sin(positions.at(i).psi/g2r),
          0.,sin(positions.at(i).psi/g2r),      cos(positions.at(i).psi/g2r))*f2c;
    for(int j=0;j<atoms.size();j++){
      Modulat m=Modulat(atoms[j]);
      V3 r=R*(atoms[j].frac(t)-ref);
      r=(c2f*r)+ref+positions.at(i).trans;
      m.frac0=r;
      if (atoms.at(j).jtf==0){
      V3 loc=(r-(ref+positions.at(i).trans));
      V3 cloc;
      atoms.at(0).mol->frac2kart(loc,cloc);
      printf("LOC %9.5f%9.5f%9.5f\n",loc.x,loc.y,loc.z);
      printf("cLOC %9.5f%9.5f%9.5f\n",cloc.x,cloc.y,cloc.z);
      loc=cloc;
      Matrix uc;
//U11 =  [0]  +zz [7]  +yy [8]  -2yz [11]  +2z [13]  -2y [14]  
      uc.m11=
        positions.at(i).tls[0]*1+
        positions.at(i).tls[7]*loc.z*loc.z+
        positions.at(i).tls[8]*loc.y*loc.y
        -2*loc.y*loc.z*positions.at(i).tls[11]+
        2*loc.z*positions.at(i).tls[15]
        -2*loc.y*positions.at(i).tls[18];
      printf("%f ",uc.m11);
      uc.m11*=1.0/(atoms.at(0).mol->zelle.as*atoms.at(0).mol->zelle.as*2.0*M_PI*M_PI);
      printf("%f \n",uc.m11);
//U22 =  [1]  +zz [6]  +xx [8]  -2xz [10]  -2z [15]  +2x [17]  
      uc.m22=positions.at(i).tls[1]+
        positions.at(i).tls[6]*loc.z*loc.z+
        positions.at(i).tls[8]*loc.x*loc.x
        -2*loc.x*loc.z*positions.at(i).tls[10]
        -2*loc.z*positions.at(i).tls[13]
        +2*loc.x*positions.at(i).tls[19];
      printf("%f ",uc.m22);
      uc.m22*=1.0/(atoms.at(0).mol->zelle.bs*atoms.at(0).mol->zelle.bs*2.0*M_PI*M_PI);
      printf("%f \n",uc.m22);
//U33 =  [2]  +yy [6]  +xx [7]  -2xy [9]  +2y [18]  -2x [19]  
      uc.m33=positions.at(i).tls[2]
        +positions.at(i).tls[6]*loc.y*loc.y
        +positions.at(i).tls[7]*loc.x*loc.x
        -2*loc.x*loc.y*positions.at(i).tls[9]
        +2*loc.y*positions.at(i).tls[14]
        -2*loc.x*positions.at(i).tls[17];
      printf("%f ",uc.m33);
      uc.m33*=1.0/(atoms.at(0).mol->zelle.cs*atoms.at(0).mol->zelle.cs*2.0*M_PI*M_PI);
      printf("%f \n",uc.m33);
//U12 =  [3]  -xy [8]  -zz [9]  +yz [10]  +xz [11]  -z [12]  +z [16]  +x [14]  -y [17]  
      uc.m12=uc.m21=positions.at(i).tls[3]
        -loc.x*loc.y*positions.at(i).tls[8]
        -loc.z*loc.z*positions.at(i).tls[9]
        +loc.y*loc.z*positions.at(i).tls[10]
        +loc.x*loc.z*positions.at(i).tls[11]
        -loc.z*positions.at(i).tls[12]
        +loc.z*positions.at(i).tls[16]
        +loc.x*positions.at(i).tls[18]
        -loc.x*positions.at(i).tls[19];
      printf("%f ",uc.m12);
      uc.m12*=1.0/(atoms.at(0).mol->zelle.as*atoms.at(0).mol->zelle.bs*2.0*M_PI*M_PI);
      printf("%f \n",uc.m12);
      uc.m21=uc.m12;

//U13 =  [4]  -xz [7]  +yz [9]  -yy [10]  +xy [11]  +y [12]  -y [20]  -x [13]  +z [19]  
      uc.m13=uc.m31=positions.at(i).tls[4]
        -loc.x*loc.z*positions.at(i).tls[7]
        +loc.y*loc.z*positions.at(i).tls[9]
        -loc.y*loc.y*positions.at(i).tls[10]
        +loc.x*loc.y*positions.at(i).tls[11]
        +loc.y*positions.at(i).tls[12]
        -loc.y*positions.at(i).tls[20]
        -loc.x*positions.at(i).tls[15]
        +loc.z*positions.at(i).tls[17];
      printf("%f ",uc.m13);
      uc.m13*=1.0/(atoms.at(0).mol->zelle.as*atoms.at(0).mol->zelle.cs*2.0*M_PI*M_PI);
      printf("%f \n",uc.m13);
      uc.m31=uc.m13;
//U23 =  [5]  -yz [6]  +xz [9]  +xy [10]  -xx [11]  -x [16]  +x [20]  +y [15]  -z [18]  
      uc.m23=uc.m32=positions.at(i).tls[5]
        -loc.y*loc.z*positions.at(i).tls[6]
        +loc.x*loc.z*positions.at(i).tls[9]
        +loc.x*loc.y*positions.at(i).tls[10]
        -loc.x*loc.x*positions.at(i).tls[11]
        -loc.x*positions.at(i).tls[16]
        +loc.x*positions.at(i).tls[20]
        +loc.y*positions.at(i).tls[13]
        -loc.z*positions.at(i).tls[14];
      printf("%f ",uc.m23);
      uc.m23*=1.0/(atoms.at(0).mol->zelle.bs*atoms.at(0).mol->zelle.cs*2.0*M_PI*M_PI);
      printf("%f \n",uc.m23);
      uc.m32=uc.m23;
      /*  Matrix n=Matrix(zelle.as,0,0,0,zelle.bs,0,0,0,zelle.cs);
          Matrix m=(n*x)*n;
          y=(transponse(c2f)*m)*(c2f);
          */
      m.uf0=uc;
      }
      printf("%-8s %f %f %f\n",atoms.at(j).atomname,r.x,r.y,r.z);
      ma.append(m);

    }
  }
}

  /*
   *
   struct INP {
   char     atomname[strgl]; // Name of the Atom(s)   
   int      lflag; //R-L
   int      icor1;            // Erstes Achse des Koordinatensystems, meist 3, also Z  
   int      icor2;            // Zweites Achse des Koordinatensystems, meist 2, also Y 
   int      nax;              // Achse 1
   int      nay1;             // Achse 2
   int      nay2;             // Achse 3
   int      na3;//3ZX
   int      jtf;              // Ordnung des Verschiebungsparametertensors(ADP)
   int      atomtype;         // Atomtyp als Integer 
   int      noofkappa;        // Number des Kappas 
   int      lmax;             // lmax 
   int      isym;             // isym 
   int      ichcon;           // chemical constraint
   double   amul;
   int   imul;
   V3   frac;          // Fraktionelle Koordinaten in X-Richtung 
   Matrix uf;           // Temperaturparameter 
   Matrix u;
   double c111, c222, c333, c112, c122, c113, c133, c223, c233, c123;
   double d1111,  d2222,  d3333, d1112,  d1113,  d1122, 
   d1123,  d1133,  d1222, d1223,  d1233,  d1333,
   d2223,  d2233,  d2333;
// Bis hier alles EintrÃÂ¤ge in xd.inp, danach berechnet   
V3   kart;          // Berechnete kart. Koordinaten in X-Richtung 
V3   ax1;           // Berechnete Achse 0 
V3   ax2;           // Berechnete Achse 1 
V3   ax3;           // Berechnete Achse 2 
int      OrdZahl;
int firstNeighbors;
int secondNeighbors;
char     invariomname[80];
V3 labPos;
int part;
int resiNr;
char ami3[5];
char shortname[strgl];
double peakHeight;
int molindex;
int sg;
double screenX,screenY;
uint GLname;
};*/ 
